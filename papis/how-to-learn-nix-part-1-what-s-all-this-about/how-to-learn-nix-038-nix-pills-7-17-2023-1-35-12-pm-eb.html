<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/ 
 saved date: Mon Jul 17 2023 13:35:12 GMT+0600 (Kyrgyzstan Time)
--><meta charset=utf-8>
<meta name=viewport content="initial-scale=1,maximum-scale=1">
<title>How to Learn Nix, Part 38: Nix Pills</title>
<link rel=canonical href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>
<style>:root{--box-radius:6px;--outer-box-radius:10px}:root{--content-bg:#fff;--gutter-bg:#eeeef3;--text-fg:#4d4d4c;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:#07c;--link-visited:#751a9a;--blockquote-accent:var(--link);--footnote-accent:#ffd2a3;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#34b553;--media-controls-contrast:#fff;--inline-code-bg:#f3f3fa;--code-block-bg:#f3f3fa;--aside-bg:#f3f3fa;--aside-warning-bg:#fff5d1;--aside-warning-fg:#ac3233;--palette-red:#c82829;--palette-green:#718c00;--palette-yellow:#eab700;--palette-orange:#f5871f;--palette-blue:#4271ae;--palette-purple:#8959a8;--palette-teal:#3e999f;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#8e908c;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--text-fg)}#dmt::before{content:"üåñ"}#dmt:hover::before{content:"üåó"}@media (prefers-color-scheme:dark){:root:not(.light-theme){--content-bg:#313233;--gutter-bg:#1d1f21;--text-fg:#d8d4cf;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:rgb(82,183,255);--link-visited:rgb(193,104,229);--blockquote-accent:var(--link);--footnote-accent:#a8612f;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#44e66c;--media-controls-contrast:#11391b;--inline-code-bg:#3c4044;--code-block-bg:#1d1f21;--aside-bg:#3c4044;--aside-warning-bg:#fff5d1;--aside-warning-fg:var(--palette-red);--palette-red:#cc6666;--palette-green:#b5bd68;--palette-yellow:#f0c674;--palette-orange:#de935f;--palette-blue:#81a2be;--palette-purple:#b294bb;--palette-teal:#8abeb7;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#969896;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--palette-black)}:root:not(.light-theme) #dmt::before{content:"üåí"}:root:not(.light-theme) #dmt:hover::before{content:"üåì"}}#dmt{width:30px;text-align:right;padding-right:4px;position:absolute;top:0;bottom:0;right:0;border:none;background-color:inherit;cursor:pointer}*{margin:0;padding:0;font:inherit;box-sizing:border-box}html{background-color:var(--gutter-bg);color:var(--text-fg)}body{font-family:system-ui,sans-serif;font-size:12pt;line-height:1.8;word-wrap:break-word}body:not(.content-page) main>aside{padding:0 var(--content-padding)}body.content-page main,body:not(.content-page) article{background-color:var(--content-bg);border-radius:var(--outer-box-radius);padding:var(--content-padding)}pre{word-wrap:normal}em,i{font-style:italic}sup{font-size:75%}sup a::before{content:"["}sup a::after{content:"]"}h1>a:only-child,h2>a:only-child{display:block}main .subsection-header+.post-list{margin-top:0}strong{font-weight:700}ol,ul{padding-left:3ch}.footnotes>ol{margin-top:1em}.footnotes li:not(.highlight){transition:background-color 1s}hr{border-style:solid;border-width:1.5px 0 0;border-radius:1px;border-color:var(--separator-color)}:not(pre)>code{white-space:pre;background-color:var(--inline-code-bg)}li{padding-left:0}blockquote{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none}a,a:active,a:visited{text-decoration:none}a:hover{text-decoration:underline}blockquote{padding:0 0 0 var(--content-padding);border-left:solid 2px var(--blockquote-accent)}aside{--content-padding:0.5em;padding:.5em;border-radius:var(--box-radius);background-color:var(--aside-bg)}a,a:active,header a:visited,footer a:visited,h1 a:visited{color:var(--link)}a:visited{color:var(--link-visited)}a.footnote-ref:visited,a.footnote-backref:visited,.notation-help-link-container a:visited{color:var(--link)}h1{font-size:130%}main *+p,main *+pre,main *+aside,main *+section,main *+article,main *+blockquote,main *+div,main *+ul,main *+ol,main *+hr,main *+h1{margin-top:1em}main pre+div.highlight{margin-top:1px}main .post-header *+h1{margin-top:0}code{font-family:Menlo,monospace;padding:0 3px;border-radius:2px}pre{background-color:var(--code-block-bg);font-size:11pt;padding:calc(.75*var(--content-padding)) var(--content-padding);line-height:1.3;border-radius:var(--box-radius);overflow-x:scroll;-webkit-overflow-scrolling:touch}pre code{padding:0;border-radius:0;display:inline-block;background-color:initial}p+p{margin-top:1em}body{margin:0 auto;--content-padding:10px;max-width:768px;-webkit-text-size-adjust:100%;position:relative}header{position:relative}header>*{height:48px;line-height:48px}.promo,.promo:visited,.promo:active{display:block;text-align:center;background-color:var(--link);color:var(--code-block-bg);border-radius:0 0 var(--outer-box-radius) var(--outer-box-radius)}header .site-title{font-size:130%}header nav{position:absolute;right:30px;top:0}@media all and (max-width:400px){:root{--outer-box-radius:0}header{text-align:center}header nav{position:static}:not(pre)>code{white-space:pre-wrap}body{--content-padding:10px}#dmt{padding:0;text-align:center;width:40px}}header ul{padding:0}header li{list-style:none;display:inline-block}header a{display:block;height:100%}header li+li{margin-left:1em}footer{padding:2em 0;font-size:.85em;text-align:center}article h1.post-title{font-size:200%}article .post-title a{display:block}article .meta{font-size:90%;font-style:italic}.post-header h1{line-height:1.2em;margin-bottom:.5em}.post-footer{text-align:center}.post-footer a{display:block}ol.post-list{list-style-position:inside;padding:0}.series-rider .series-name{font-style:italic}.highlight{color:var(--palette-text)}.highlight .k{color:var(--palette-purple)}.highlight .n{color:var(--palette-text)}.highlight .o{color:var(--palette-teal)}.highlight .p{color:var(--palette-text)}.highlight .c1{color:var(--palette-dim)}.highlight .kn{color:var(--palette-teal)}.highlight .nb{color:var(--palette-text)}.highlight .no{color:var(--palette-red)}.highlight .mi{color:var(--palette-orange)}.highlight .s2{color:var(--palette-green)}.highlight .s1{color:var(--palette-green)}</style>
<meta property=og:title content="How to Learn Nix, Part 38: Nix Pills">
<meta property=og:type content=website>
<meta property=og:url content=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>
<meta name=description content="I don‚Äôt know about the word ‚Äúpills.‚Äù
The word ‚Äúpills‚Äù makes me think of medicine; it makes me think of the idiom ‚Äúa bitter pill to swallow;‚Äù it makes me think of sweaters that just came out of the wash. It does not make me think of‚Ä¶ documentation, or learning.
I assume that the title is meant to evoke ‚Äúbite-sized‚Äù or something like that. I don‚Äôt know. It‚Äôs weird a weird choice, for a series.">
<meta property=og:description content="I don‚Äôt know about the word ‚Äúpills.‚Äù
The word ‚Äúpills‚Äù makes me think of medicine; it makes me think of the idiom ‚Äúa bitter pill to swallow;‚Äù it makes me think of sweaters that just came out of the wash. It does not make me think of‚Ä¶ documentation, or learning.
I assume that the title is meant to evoke ‚Äúbite-sized‚Äù or something like that. I don‚Äôt know. It‚Äôs weird a weird choice, for a series.">
<meta property=og:image content=https://ianthehenry.com/checkerboard.png>
<meta name=twitter:creator content=@ianthehenry>
<meta name=twitter:card content=summary>
<link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAHH1uIDShg/xEsZv8GFk3/CSJb/wgZT/8IGU//CBlP/wkiW/8HGE7/CBlP/wkiW/8HIFX/BxhO/wcgVf8OK2t7JDhz/wcfW/8NNn7/CSpq/wkjYf8MJGP/DCJg/w02ef9SqdX/TKHJ/1my2f9Moc3/UqzV/1Cr1v9Pocf/Ditr/xk2cf8KJGL/CjR8/wwva/8RK2r/Cido/w8qa/8LLW//TqjT/1Gnz/9bsNf/Sp/K/1Wt2f9Wrtj/UKjQ/w8xc/8gPHj/Di5w/xk4ef8TL27/Dy5u/xU3fv8QLGv/Ditr/1qy3f9dttv/Yrje/0ecx/9Knsz/U6fQ/1m13f8YN3n/JjZx/wszdv8YOXz/Eilm/xc3e/8dSZT/GDJz/xk/hv9hu+P/WbHZ/1mv1v9Kn8z/WLHd/1212v9ds9n/Eipr/xcqYv8SOX3/GzRz/xQrZ/8aM3D/HEuU/xc0df8fPYD/Yrre/1603P9dt9z/VKvY/1iz4v9etNr/Y73m/xk5fP8cMm3/JEWK/xc0dP8eO3v/Hjd4/ydRnP8WM3P/Gjd3/2bA5/9dtd//Ybng/2K95v9ct+P/Ybnf/2K95/8oS5L/GChg/xxBh/8lSIz/GC5s/yM5ev8hRoz/HTp7/yE6e/9Zsdz/YLzn/2jF7v9ryfL/YLzn/1qu1f9htdz/GDyD/y0/ev9qx/X/acDn/1235v9euun/Yb3r/1665v9owu7/GUOL/yhGh/8nUJL/MkmI/yBFiP8jOHb/MVag/yM+gv8VMGv/acXx/27G7/9szv3/bMb1/2zD6/9vy/X/edf5/yBHjv8yS47/JEuO/zVLiv8nS5D/LkOB/yRXpP8lQoT/H0WI/3fS+P910Pf/b8/8/2bB7/991Pn/eNb+/3nT+P8pS5L/O1GS/ytUnP86UJH/NF2k/zNLjP8sXKv/JkCB/x4+ff+B2/3/etT9/4He//922f//fNf//3TT//991/7/NU6N/zZSkP86Zav/PlWR/zFepv88ZKb/MF2n/yQ/gf8bNXH/fd3//3/b//+K6P//ft///3vV//993f//gdz//0hWlf9FZKX/RmOj/0JXlv9IeMP/QXKz/0Jsuf8eO3z/Hjt2/3vd//+C3v//ju3//3zg//+H4v//guL//4nj//9HXp3/UGur/ztgqf9JYqP/S3G4/05ur/9EbLT/Hjt7/zNJhf+G4///heT//4rq//+E5///iOT//4jr//+G4///UXO0/09iov9EX6H/SWWn/1V5wP9Kaa7/RGSp/ydLj/8NKGCfDShg/x8+d/8RLGb/CBlP/wYWTf8GFEj/CBNH/wooZP8JIlv/CCJd/woWSf8HGE7/ByBV/wwgU/8fO3mfAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body class=content-page>
<a class=promo href=https://janet.guide/ target=_blank><i>psst, hey kid, wanna read a weird programming book</i></a>
<header>
<a class=site-title href=https://ianthehenry.com/>Ian Henry</a>
<nav>
<ul><li><a href=https://ianthehenry.com/about/>About</a><li><a href=https://ianthehenry.com/posts/>Blog</a><li><a href=https://ianthehenry.com/stuff/>Stuff</a></ul>
</nav>
<button id=dmt title="Toggle dark mode"></button>
</header>
<main>
<aside class=series-rider>
<p>This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>, a rambling diary in which I work my way through the Nix manual in excrutiating detail.</p>
</aside>
<article class=post>
<div class=post-header>
<time class=meta datetime=2021-06-05>June 5, 2021</time>
<h1 class=post-title>
<a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>How to Learn Nix, Part&nbsp;38:<br>Nix Pills</a></h1>
</div>
<div class=post-content><p>I don‚Äôt know about the word ‚Äúpills.‚Äù</p>
<p>The word ‚Äúpills‚Äù makes me think of medicine; it makes me think of the idiom ‚Äúa bitter pill to swallow;‚Äù it makes me think of sweaters that just came out of the wash. It does not make me think of‚Ä¶ documentation, or learning.</p>
<p>I <em>assume</em> that the title is meant to evoke ‚Äúbite-sized‚Äù or something like that. I don‚Äôt know. It‚Äôs weird a weird choice, for a series.</p>
<p>But it‚Äôs distinctive. I‚Äôll give it that. If you say ‚ÄúNix pills,‚Äù people know what you‚Äôre talking about. No matter how unsavory the connotation, I suppose it‚Äôs well-marketed.</p>
<p>Anyway. <em>Nix Pills</em> started life as a series of blog posts in 2014, written by a real human person writing for the greater good of all humankind, and I already feel a little bad for saying I think the title is weird.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> But it has since become a part of the official documentation ‚Äì at least, there is an updated(?) version of the blog series hosted on <a href=https://nixos.org/>https://nixos.org</a> and linked to from <a href=https://nixos.org/learn.html>the official ‚ÄúLearn‚Äù page</a>, so I‚Äôm calling it official documentation, and I‚Äôm gonna read it.</p>
<p>But‚Ä¶ the audience of the Pills series appears to be someone who has not encountered Nix before. And I have been encountering Nix for the better part of four months now, so I am not really going to be a good judge of what‚Äôs confusing, what could be clearer, etc. In other words, I am not really doing this to audit the documentation ‚Äì I don‚Äôt have any intention of trying to improve these blog posts from 2014 ‚Äì but rather because I think I might learn something.</p>
<p>So this is going to go a lot faster than a typical post: most of these concepts are things that I‚Äôve encountered before.</p>
<p>Let‚Äôs dive in.</p>
<h1 id=chapter-1-why-you-should-give-it-a-try>Chapter 1. Why You Should Give it a Try</h1>
<p>Most of this chapter is concerned with extolling the virtues of Nix and motivating the series itself; there is little in the way of information for an existing Nix user.</p>
<blockquote>
<p>This series aims to complement the existing explanations from the more formal documents.</p>
</blockquote>
<p>This is interesting. I‚Äôve heard Nix Pills described as a ‚Äútextbook, from first principles‚Äù approach to explaining Nix ‚Äì i.e., something I would consider more traditionally formal than the actual manuals. Which didn‚Äôt seem very formal at all. But maybe they were more so, when this was written?</p>
<blockquote>
<p>Considering Nixpkgs is a completely new repository of all the existing software, with a completely fresh concept, and with few core developers but overall year-over-year increasing contributions, the current state is more than acceptable and beyond the experimental stage. In other words, it‚Äôs worth your investment.</p>
</blockquote>
<p>It is weird to think of Nixpkgs ‚Äì one of the largest package repositories in the world ‚Äì as being new in 2014. 2014 wasn‚Äôt that long ago! But I look through the Nixpkgs history, and see that the first commit was created in 2003. Okay. That‚Äôs closer to what I expected. Using the term to mean novel, I suppose.</p>
<h1 id=chapter-2-install-on-your-running-system>Chapter 2. Install on Your Running System</h1>
<p>Installation. Actually our first nugget of information:</p>
<blockquote>
<p>Yes, Nix also has a database. It‚Äôs stored under <code>/nix/var/nix/db</code>. It is a sqlite database that keeps track of the dependencies between derivations.</p>
<p>The schema is very simple: there‚Äôs a table of valid paths, mapping from an auto increment integer to a store path.</p>
<p>Then there‚Äôs a dependency relation from path to paths upon which they depend.</p>
<p>You can inspect the database by installing <code>sqlite</code> (<code>nix-env -iA sqlite -f '&lt;nixpkgs&gt;'</code>) and then running <code>sqlite3 /nix/var/nix/db/db.sqlite</code>.</p>
</blockquote>
<p>I don‚Äôt remember the manual ever describing where to find the database, or what was in it, or really anything about it. It‚Äôs nice to call that out up front. It doesn‚Äôt really explain <em>why</em> the database exists, but this is just the installation chapter ‚Äì perhaps it will go into more detail later (although it‚Äôs already gone into more detail than the manual ever did).</p>
<p>Apparently this chapter is quite a bit more than installation. It describes the user environment used by <code>nix-env</code> commands, it describes channels and Nixpkgs. It even teases:</p>
<blockquote>
<p>We‚Äôll talk about <code>manifest.nix</code> more in the next article.</p>
</blockquote>
<p>Neat! That‚Äôs something I still don‚Äôt <em>totally</em> understand, and that the manual certainly never explained.</p>
<h1 id=chapter-3-enter-the-environment>Chapter 3. Enter the Environment</h1>
<p>Explains that a user environment is a directly full of symlinks to every file in all of your installed derivations, which I think is very useful to point out: that was something I did not understand from reading the manual, and <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>had to discover for myself</a> in the process of installing the first derivation I wrote.</p>
<blockquote>
<p>There isn‚Äôt anything like apt which solves a SAT problem in order to satisfy dependencies with lower and upper bounds on versions. There‚Äôs no need for this because all the dependencies are static: if a derivation X depends on a derivation Y, then it always depends on it. A version of X which depended on Z would be a different derivation.</p>
</blockquote>
<p>This is a pretty important statement. Because Nix can have multiple versions of a package installed at once, there‚Äôs no need to have version bounds. Chapter one made this point as well, but it feels worth repeating.</p>
<blockquote>
<p>The <code>manifest.nix</code> file contains metadata about the environment, such as which derivations are installed. So that <code>nix-env</code> can list, upgrade or remove them. And yet again, the current <code>manifest.nix</code> can be found at <code>~/.nix-profile/manifest.nix</code>.</p>
</blockquote>
<p>That‚Äôs interesting: so presumably <code>nix-env -q</code> operates by looking at <code>manifest.nix</code>. I wonder what that file actually looks like. I feel like I could understand it now‚Ä¶</p>
<pre><code>$ cat ~/scratch/ugh.nix
(import &lt;nixpkgs&gt; {}).lib.generators.toPretty { multiline = true; } (import /Users/ian/.nix-profile/manifest.nix)

$ nix-instantiate --eval --strict ~/scratch/ugh.nix
error: attribute 'drvPath' missing, at /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/lib/generators.nix:251:24
</code></pre>
<p>Hmm. No. The <code>toPretty</code> function seems to assume that any record with <code>{ type = "derivation"; }</code> must also have a <code>drvPath</code>. Which is not‚Ä¶ looking at the source here, it seems this is <em>not</em> going to pretty-print an expression, but give me output like <code>&lt;derivation /nix/store/whatever&gt;</code>. I don‚Äôt want that. It‚Äôs a set. Just‚Ä¶ just pretty-print it, please‚Ä¶</p>
<p>And no, there is no option to enable that behavior.</p>
<p>So‚Ä¶ I still have no idea how to pretty-print a Nix expression, without resorting to third-party tools.</p>
<p>But I‚Äôve read the manuals already. I‚Äôm open to the idea of third-party tools, at this point, as I‚Äôm pretty sure there is no first-party support. I google, and find something called <a href=https://github.com/nixcloud/nix-beautify><code>nix-beautify</code></a>.</p>
<p>It‚Äôs not a part of Nixpkgs, apparently, but there are instructions to install it from their <code>default.nix</code> expression:</p>
<blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nix-env -i nix-beautify -f https://github.com/nixcloud/nix-beautify/archive/master.tar.gz
</code></pre></div></blockquote>
<p>But I don‚Äôt want to install it, of course. I‚Äôd rather just <code>nix-shell -p</code> it. But I‚Äôve never done that with anything but <code>nixpkgs</code> before. I know that <code>nix-shell -p</code> doesn‚Äôt accept <code>-f</code> and works by <code>-I</code>, so without really thinking about it I try this:</p>
<pre><code>$ nix-shell -p nix-beautify -I nixpkgs=https://github.com/nixcloud/nix-beautify/archive/master.tar.gz
unpacking 'https://github.com/nixcloud/nix-beautify/archive/master.tar.gz'...
[1]    7103 segmentation fault  nix-shell -p nix-beautify -I
</code></pre>
<p>Hmm. I suspect this is because the first thing that <code>default.nix</code> does is <code>import &lt;nixpkgs&gt;</code>, and this causes a stack overflow. Didn‚Äôt really think about it, but yeah. Okay.</p>
<p>Fine. I install it, annoyed, and remember to uninstall it afterwards.</p>
<p>Something is weird with my shell completion, though, and I have to manually run <code>rehash</code> after installing it in order to not have to type out the whole executable name. Weird. Can‚Äôt remember the last time I had to do that.</p>
<p>Anyway, does it work?</p>
<pre tabindex=0><code>$ nix-beautify manifest.nix

</code></pre><p>It‚Äôs just hanging. It‚Äôs just hanging there. It can only read from stdin, can‚Äôt it.</p>
<pre tabindex=0><code>$ nix-beautify &lt;manifest.nix
(extremely long, unprettified string of Nix expression)
</code></pre><p>Sigh. So that‚Äôs‚Ä¶ not a thing. Looking at the example in the README, I suspect that this can only <em>indent</em> Nix expressions, not actually‚Ä¶ beautify them. Sigh.</p>
<p>I find <a href=https://github.com/Gabriel439/nixfmt>another project</a>, from <a href=https://www.haskellforall.com/>a name I trust</a>. The README is‚Ä¶ not reassuring, but it can‚Äôt be any worse than <code>nix-beautify</code>. This one is already in nixpkgs, so‚Ä¶</p>
<pre tabindex=0><code>$ nix-shell -p nixfmt

[nix-shell:~]$ nixfmt ~/.nix-profile/manifest.nix
nixfmt: /Users/ian/.nix-profile: openTempFileWithDefaultPermissions: permission denied (Permission denied)
</code></pre><p>Hmmmmm. I suspect this is a symlink issue? Maybe?</p>
<pre tabindex=0><code>[nix-shell:~]$ cp ~/.nix-profile/manifest.nix ~/scratch

[nix-shell:~]$ nixfmt ~/scratch/manifest.nix
</code></pre><p>Ah. No. It literally was permission denied, because this was trying to reformat in-place, instead of just printing out the formatted version. Okay.</p>
<p><em>Well anyway</em> we can now look at the pretty-printed <code>manifest.nix</code>:</p>
<pre><code>$ cat ~/scratch/manifest.nix
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=p>[</span>
  <span class=p>{</span>
    <span class=n>meta</span> <span class=o>=</span> <span class=p>{</span>
      <span class=n>available</span> <span class=o>=</span> <span class=no>true</span><span class=p>;</span>
      <span class=n>broken</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>changelog</span> <span class=o>=</span>
        <span class=s2>"https://git.savannah.gnu.org/cgit/hello.git/plain/NEWS?h=v2.10"</span><span class=p>;</span>
      <span class=n>description</span> <span class=o>=</span> <span class=s2>"A program that produces a familiar, friendly greeting"</span><span class=p>;</span>
      <span class=n>homepage</span> <span class=o>=</span> <span class=s2>"https://www.gnu.org/software/hello/manual/"</span><span class=p>;</span>
      <span class=n>insecure</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>license</span> <span class=o>=</span> <span class=p>{</span>
        <span class=n>fullName</span> <span class=o>=</span> <span class=s2>"GNU General Public License v3.0 or later"</span><span class=p>;</span>
        <span class=n>shortName</span> <span class=o>=</span> <span class=s2>"gpl3Plus"</span><span class=p>;</span>
        <span class=n>spdxId</span> <span class=o>=</span> <span class=s2>"GPL-3.0-or-later"</span><span class=p>;</span>
        <span class=n>url</span> <span class=o>=</span> <span class=s2>"https://spdx.org/licenses/GPL-3.0-or-later.html"</span><span class=p>;</span>
      <span class=p>};</span>
      <span class=n>longDescription</span> <span class=o>=</span> <span class=s1>''
</span><span class=s1>        GNU Hello is a program that prints "Hello, world!" when you run it.
</span><span class=s1>        It is fully customizable.
</span><span class=s1>      ''</span><span class=p>;</span>
      <span class=n>maintainers</span> <span class=o>=</span> <span class=p>[{</span>
        <span class=n>email</span> <span class=o>=</span> <span class=s2>"..."</span><span class=p>;</span>
        <span class=n>github</span> <span class=o>=</span> <span class=s2>"edolstra"</span><span class=p>;</span>
        <span class=n>githubId</span> <span class=o>=</span> <span class=mi>1148549</span><span class=p>;</span>
        <span class=n>name</span> <span class=o>=</span> <span class=s2>"Eelco Dolstra"</span><span class=p>;</span>
      <span class=p>}];</span>
      <span class=n>name</span> <span class=o>=</span> <span class=s2>"hello-2.10"</span><span class=p>;</span>
      <span class=n>outputsToInstall</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"out"</span> <span class=p>];</span>
      <span class=n>platforms</span> <span class=o>=</span> <span class=p>[</span> <span class=o>...</span> <span class=p>];</span>
      <span class=n>position</span> <span class=o>=</span>
        <span class=s2>"/nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/applications/misc/hello/default.nix:15"</span><span class=p>;</span>
      <span class=n>unfree</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
      <span class=n>unsupported</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=n>name</span> <span class=o>=</span> <span class=s2>"hello-2.10"</span><span class=p>;</span>
    <span class=n>out</span> <span class=o>=</span> <span class=p>{</span>
      <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10"</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=n>outPath</span> <span class=o>=</span> <span class=s2>"/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10"</span><span class=p>;</span>
    <span class=n>outputs</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>"out"</span> <span class=p>];</span>
    <span class=n>system</span> <span class=o>=</span> <span class=s2>"x86_64-darwin"</span><span class=p>;</span>
    <span class=n>type</span> <span class=o>=</span> <span class=s2>"derivation"</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=o>...</span>
<span class=p>]</span>
</code></pre></div><p>It‚Äôs long. Incredibly long. So long that I only included the very first entry, and even then I omitted the <code>platforms</code> key.</p>
<p>So it‚Äôs a list of every installed derivation in the environment, and nothing else. Which kind of surprises me ‚Äì I thought there‚Äôd be <em>something</em> in there ‚Äì but okay. Whatever. Good enough.</p>
<p>What were we talking about?</p>
<h1 id=chapter-4-the-basics-of-the-language>Chapter 4. The Basics of the Language</h1>
<blockquote>
<p>Attempting to perform division in Nix can lead to some surprises.</p>
<pre tabindex=0><code>nix-repl&gt; 6/3
/home/nix/6/3
</code></pre></blockquote>
<p>I‚Äôm glad the chapter calls this out. I haven‚Äôt made this mistake <em>yet</em>,<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and I totally understand (and agree with) Nix‚Äôs choice, but this is still a gotcha. A very small gotcha, since I imagine you just aren‚Äôt doing a lot of division in your Nix expressions, but still worth noting.</p>
<p>Let‚Äôs see‚Ä¶ points out kebab-case identifiers, something that either wasn‚Äôt explained or that I missed when I read the manual. That‚Äôs nice.</p>
<p>Talks about string escapes. I remember the manual giving an absolutely <a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>unintelligible description</a> of these:</p>
<blockquote>
<p>Since <code>${</code> and <code>''</code> have special meaning in indented strings, you need a way to quote them. <code>$</code> can be escaped by prefixing it with <code>''</code> (that is, two single quotes), i.e., <code>''$</code>. <code>''</code> can be escaped by prefixing it with <code>'</code>, i.e., <code>'''</code>. <code>$</code> removes any special meaning from the following <code>$</code>.</p>
</blockquote>
<p>Meanwhile, Nix Pills explains it with an actual example:</p>
<blockquote>
<p>Escaping <code>${...}</code> within double quoted strings is done with the backslash. Within two single quotes, it‚Äôs done with <code>''</code>:</p>
<pre tabindex=0><code>nix-repl&gt; "\${foo}"
"${foo}"
nix-repl&gt; ''test ''${foo} test''
"test ${foo} test"
</code></pre></blockquote>
<p>Doesn‚Äôt give an example of the ‚Äú<code>$</code> removes any special meaning from the following <code>$</code>‚Äù bit, though. Maybe we can observe that?</p>
<pre tabindex=0><code>nix-repl&gt; ''hello ${world}''
error: undefined variable 'world' at (string):1:11

nix-repl&gt; ''hello $${world}''
"hello $${world}" 
</code></pre><p>Okay. Weird. Not really‚Ä¶ I mean I guess it makes sense that it‚Äôs different from <code>''${world}</code>, but‚Ä¶ huh? It‚Äôs weird. It‚Äôs a weird thing. It‚Äôs weird that there‚Äôs a redundant escape syntax. You can get the same result like this:</p>
<pre tabindex=0><code>nix-repl&gt; ''hello $''${world}''
"hello $${world}"
</code></pre><p>Anyway.</p>
<p>I learn from this chapter that you can bind multiple identifiers in a single <code>let</code> expression:</p>
<pre><code>nix-repl&gt; let a = 3; b = 4; in a + b
7
</code></pre>
<p>Which‚Ä¶ <em>sort of</em> explains the insane choice to have a semicolon before the <code>in</code>, but not‚Ä¶ really. This reminds me of requiring terminal semicolons in attribute sets. Which is to say: why would you do this.</p>
<p>The chapter explains <code>with</code>, but not the weird multiple-scope <code>with</code>-not-shadowing-explicitly-bound-identifiers thing that the manual described.</p>
<p>Laziness gets a couple sentences, but no mention of gotchas or patterns or anything. Just an intro.</p>
<h1 id=chapter-5-functions-and-imports>Chapter 5. Functions and Imports</h1>
<p>Explains currying and function application, which the manual‚Ä¶ just didn‚Äôt? I don‚Äôt remember it talking about that. But maybe I‚Äôve forgotten.</p>
<p>Lotsa function stuff. Pattern matching, optional arguments, etc. Nothing we haven‚Äôt seen already.</p>
<p>Talks about <code>import</code>, but no mention of <code>&lt;path&gt;</code> syntax yet. I would probably introduce those around the same time, since most import expressions I‚Äôve seen have been <code>import &lt;nixpkgs&gt;</code>.</p>
<h1 id=chapter-6-our-first-derivation>Chapter 6. Our First Derivation</h1>
<blockquote>
<p>Let‚Äôs try to fake the name of the system:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; d
¬´derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv¬ª
</code></pre>
<p>Oh oh, what‚Äôs that? Did it build the derivation? No it didn‚Äôt, but <strong>it did create the .drv file</strong>. <code>nix repl</code> does not build derivations unless you tell to do so.</p>
</blockquote>
<p>Whoa. That‚Äôs weird. I didn‚Äôt really think about‚Ä¶ <code>nix repl</code> actually instantiating <code>.drv</code> files. Why‚Ä¶? Why does it do that? Does it actually‚Ä¶?</p>
<pre tabindex=0><code>nix-repl&gt; derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
¬´derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv¬ª

$ cat /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
Derive([("out","/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname","","")],[],[],"mysystem","mybuilder",[],[("builder","mybuilder"),("name","myname"),("out","/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"),("system","mysystem")])
</code></pre><p>Just‚Ä¶ what? What possible use‚Ä¶ is this? This feels like a weird implementation leak of the <code>repl</code>. This can‚Äôt be intentional, can it? There‚Äôs no reason you would ever <em>want</em> this behavior, is there?</p>
<p>Anyway, the chapter spends some time discussing <code>.drv</code> files, which I appreciate. They were given absolutely no treatment in the Nix manual, which is crazy to me.</p>
<p>I learn something very valuable from this: <code>nix show-derivation</code>. Basically a way to pretty-print those horrible ‚ÄúATerm‚Äù files, which is something that <a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>I was looking for recently</a>. But it doesn‚Äôt just pretty-print it, it also annotates each field with a name, and prints it in JSON ‚Äì an actual format with actual tools for working with it.</p>
<p>Let‚Äôs look at the derivation I was trying to inspect last time, that I ended up <code>sed</code>ing into a sexp just to see it more clearly:</p>
<pre><code>$ nix show-derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv
{
  "/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell"
      }
    },
    "inputSrcs": [
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv": [
        "out"
      ],
      "/nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drv": [
        "out"
      ],
      "/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv": [
        "out"
      ],
      "/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv": [
        "out"
      ]
    },
    "platform": "x86_64-darwin",
    "builder": "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash",
    "args": [
      "-e",
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "env": {
      "__darwinAllowLocalNetworking": "",
      "__impureHostDeps": "/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh",
      "__propagatedImpureHostDeps": "",
      "__propagatedSandboxProfile": "",
      "__sandboxProfile": "",
      "buildInputs": "",
      "builder": "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostHost": "",
      "depsHostHostPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "doCheck": "",
      "doInstallCheck": "",
      "name": "nix-shell",
      "nativeBuildInputs": "/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2 /nix/store/axzlbh5ji9pr97mi04f70lizn22bkxj5-python3.9-cram-0.7",
      "nobuildPhase": "echo\necho \"This derivation is not meant to be built, aborting\";\necho\nexit 1\n",
      "out": "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell",
      "outputs": "out",
      "patches": "",
      "phases": "nobuildPhase",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "shellHook": "",
      "stdenv": "/nix/store/59hdixd6qf2jq5mj0bqiwrhy7621wa7j-stdenv-darwin",
      "strictDeps": "",
      "system": "x86_64-darwin"
    }
  }
}
</code></pre>
<p>Ahhh. Much better. It seems that my guesses were right about the different values, also ‚Äì <code>inputSrcs</code> and <code>inputDrvs</code>. Nothing about the weird empty strings, but I <em>happened</em> to stumble upon an answer, while <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>re-reading an old blog post of mine</a>:</p>
<blockquote>
<pre><code>[ ( "out"
, "/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz"
, "sha256"
, "31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b"
) ]
</code></pre>
</blockquote>
<aside>
<p>I prettified that‚Ä¶ wrong, but whatever.</p>
</aside>
<p>It seems that those values are meaningful only for a ‚Äúfixed-output derivation,‚Äù but instead of just being omitted in that case (as they are in the <code>show-derivation</code> output), they appear as empty strings:</p>
<pre><code>[ ( "out"
  , "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell"
  , ""
  , ""
  ) ]
</code></pre>
<p>Okay, yeah, I guess it is a tuple ‚Äì probably, who knows what data types this format allows ‚Äì but, like, gross.</p>
<p>I‚Äôm very glad that this explains these files and why they exist and what they look like. I happened to have gone on this journey myself, but it feels important enough that I wish the manual spent some time explaining it.</p>
<blockquote>
<p>Important: the hash of the out path is based solely on the input derivations in the current version of Nix, not on the contents of the build product. It‚Äôs possible however to have content-addressable derivations for e.g. tarballs as we‚Äôll see later on.</p>
</blockquote>
<p>Are they actually content-addressable? I know they‚Äôre ‚Äúfixed output‚Äù but‚Ä¶ I thought that was just an assertion, not actually reflected in the path itself.</p>
<p>Let‚Äôs look at one. Let‚Äôs see‚Ä¶ I‚Äôve got:</p>
<pre tabindex=0><code>/nix/store/bd5v53gnpwcgdlgq9hc2x8l8xm8rsz9h-pcre-ocaml-7.2.3.tar.gz.drv
</code></pre><p>That sounds like it oughtta be fixed-output.</p>
<pre tabindex=0><code>$ nix show-derivation /nix/store/bd5v53gnpwcgdlgq9hc2x8l8xm8rsz9h-pcre-ocaml-7.2.3.tar.gz.drv \
&gt; | jq '.[] | .outputs'
{
  "out": {
    "path": "/nix/store/67wja6vzp1da9adlbimb6839malmnlm0-pcre-ocaml-7.2.3.tar.gz",
    "hashAlgo": "sha256",
    "hash": "6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666"
  }
}
</code></pre><p>So‚Ä¶ it‚Äôs hard to tell, because one is in hex, and the other is in‚Ä¶ checks notes‚Ä¶ <code>base32</code>. But my notes also tell me this handy helper:</p>
<pre tabindex=0><code>$ nix to-base32

$ nix to-base32 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
error: hash '6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666' does not include a type

$ nix to-base32 sha256 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
error: hash 'sha256' does not include a type

$ nix to-base32 --help
Usage: nix to-base32 &lt;FLAGS&gt;... &lt;STRINGS&gt;...

Summary: convert a hash to base-32 representation.

Flags:
      --type &lt;TYPE&gt;  hash algorithm ('md5', 'sha1', 'sha256', or 'sha512')

Note: this program is EXPERIMENTAL and subject to change.
</code></pre><p>Why‚Ä¶ does a conversion function need to know the algorithm? Aren‚Äôt we just converting bytes into a different representation? What‚Ä¶? Whatever:</p>
<pre tabindex=0><code>$ nix to-base32 --type sha256 6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0e6f4666
0rj6dw79px4sj2kq0iss2nzq3rnsn9wivvc0f44wa1mppr6njfb3
</code></pre><p>Hmm. That‚Äôs still more characters than occur in the store path, and it doesn‚Äôt seem like the store path is a prefix or anything. So‚Ä¶ I‚Äôm gonna say it‚Äôs not content-addressed? At least not by default. But the chapter did say that it‚Äôs only ‚Äú<em>possible</em>‚Äù to have content-addressable derivations. It did not say that fixed-output derivations were content-addressable. So that‚Äôs an open question, I guess.</p>
<p>Or I don‚Äôt really understand what ‚Äúcontent-addressable‚Äù means. That‚Äôs‚Ä¶ not unlikely.</p>
<p>Okay. Overall, this chapter seems <em>great</em>. This is a ton of useful information, most of which did not exist in the manual in any form. I‚Äôm not going to write all of my thoughts, but this is certainly something I would recommend new Nix users to read. I can‚Äôt really judge how approachable it is, because I already know all these things, but it seems to cover basically everything I had questions about before.</p>
<p>I learned also about the magic value <code>set.outPath</code>:</p>
<pre tabindex=0><code>nix-repl&gt; { outPath = "hello" }
error: syntax error, unexpected '}', expecting ';', at (string):1:21

nix-repl&gt; { outPath = "hello"; }
{ outPath = "hello"; }

nix-repl&gt; builtins.toString { outPath = "hello"; }
"hello"
</code></pre><p>Feels like that‚Äôs worth mentioning in a discussion of <code>toString</code>. The manual described the special key <code>__toString</code>, but not this.</p>
<p>We‚Äôre going through a lot of stuff without any mention of <code>stdenv</code>, which‚Ä¶ might be confusing? I can‚Äôt really tell. Like, if this was your <em>absolute first exposure</em>, you wouldn‚Äôt have any questions here. But if you‚Äôve seen some Nix before, I could imagine this being confusing because of how different it is to what you‚Äôve already seen? I admire that we‚Äôre building up things from scratch, with only Nix, and not really discussing Nixpkgs at all. But it never explicitly <em>says</em> that‚Äôs what it‚Äôs doing.</p>
<p>I dunno. I shouldn‚Äôt speculate on how understandable this is. I have lost all ability to judge that.</p>
<p>I learned this repl idiom:</p>
<pre tabindex=0><code>nix-repl&gt; :l &lt;nixpkgs&gt;
Added 14075 variables.
</code></pre><p>Instead of:</p>
<pre tabindex=0><code>nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
</code></pre><p>As I have been doing. That‚Äôs a neat trick.</p>
<h1 id=chapter-7-working-derivation>Chapter 7. Working Derivation</h1>
<p>It also took me <a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>two</a> <a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>posts</a> to get to a working derivation. And I was following the manual!</p>
<p>I dunno; I like this chapter too? This seems good. I don‚Äôt learn anything, but I think I would recommend it to others. It starts off in a <code>nix repl</code>, which is kind of neat ‚Äì declaring inline derivations, building them with <code>:b</code>‚Ä¶ it‚Äôs weird, sure, but probably a decent first intro? Although I must repeat: it‚Äôs not my first intro, so I don‚Äôt really know what I‚Äôm talking about. And it doesn‚Äôt linger there, but moves on quickly to writing a ‚Äúreal‚Äù <code>default.nix</code> file.</p>
<blockquote>
<p><code>nix-build</code> does two jobs:</p>
<ul>
<li><code>nix-instantiate</code>: parse and evaluate <code>simple.nix</code> and return the .drv file corresponding to the parsed derivation set</li>
<li><code>nix-store -r</code>: realise the .drv file, which actually builds it.</li>
</ul>
</blockquote>
<p>I think it‚Äôs nice to call out the primitive operations when discussing the porcelain. Good work.</p>
<h1 id=chapter-8-generic-builders>Chapter 8. Generic Builders</h1>
<p>Okay. So I think what‚Äôs happening here is: Nix Pills is going to walk us through <code>mkDerivation</code> and the <code>$stdenv/setup</code> script, and motivate all of the complexities there, starting from scratch. This sort of gets us started, showing how it puts <code>buildInputs</code> on our <code>PATH</code> and makes <code>sed</code> available by default and all that.</p>
<p>But it doesn‚Äôt <em>say</em> that‚Äôs what it‚Äôs doing. And although I can sort of appreciate that the individual steps here do make sense in isolation, I think that having the end goal in mind would make it all more‚Ä¶ concrete.</p>
<h1 id=chapter-9-automatic-runtime-dependencies>Chapter 9. Automatic Runtime Dependencies</h1>
<blockquote>
<p>NAR is the Nix ARchive. First question: why not tar? Why another archiver? Because commonly used archivers are not deterministic. They add padding, they do not sort files, they add timestamps, etc.. Hence NAR, a very simple deterministic archive format being used by Nix for deployment. NARs are also used extensively within Nix itself as we‚Äôll see below.</p>
</blockquote>
<p>That‚Äôs actually really nice to call out. I assumed NAR files were <em>something</em> more than just bundles of files. But this makes me think that NARs are just‚Ä¶ you know. Just the thing that it says. Why, then, is it called Nix Archive? There‚Äôs nothing Nix-specific, there, is there? Hmm.</p>
<blockquote>
<p>Build dependencies are automatically recognized by Nix once they are used in any <code>derivation</code> call, but we never specify what are the runtime dependencies for a derivation.</p>
</blockquote>
<p>Okay. Yes. I‚Äôm on board here.</p>
<blockquote>
<p>There‚Äôs really black magic involved. It‚Äôs something that at first glance makes you think ‚Äúno, this can‚Äôt work in the long term‚Äù, but at the same time it works so well that a whole operating system is built on top of this magic.</p>
<p>Steps:</p>
<ol>
<li>Dump the derivation as NAR, a serialization of the derivation output. Works fine whether it‚Äôs a single file or a directory.</li>
<li>For each build dependency .drv and its relative out path, search the contents of the NAR for this out path.</li>
<li>If found, then it‚Äôs a runtime dependency.</li>
</ol>
</blockquote>
<p>This‚Ä¶ does not sound like black magic to me. This sounds like exactly how I would expect it to work.</p>
<p>Actually, I originally expected it would just search for anything that looked like a store path in the output. But as soon as I tried <a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>manually adding a text file full of store paths</a> to the store, I realized why that doesn‚Äôt make sense: derivations aren‚Äôt allowed to get their hands on any random paths. The only way it can <em>know</em> a store path is if that store path is a dependency of the <code>.drv</code> file.</p>
<p>So, okay. This makes me wonder how cross-compilation works, since it sounds like all runtime dependencies are subsets of build-time dependencies, but the architectures might be different‚Ä¶ but I guess that doesn‚Äôt matter, though? Different architectures are different derivations. Different paths. Not really a problem. Okay.</p>
<p>Now it‚Äôs motivating the <code>patchelf</code> and <code>strip</code> thing, by showing how a trivial C program ends up with (by this heuristic) a runtime dependency on <code>gcc</code>. This is actually really great: a better description of why the <code>fixupPhase</code> exists than the Nixpkgs manual gave, if I‚Äôm remembering right.</p>
<h1 id=chapter-10-developing-with-nix-shell>Chapter 10. Developing with <code>nix-shell</code></h1>
<blockquote>
<p>First thing to notice, we call <code>nix-shell</code> on a nix expression which returns a derivation. We then enter a new bash shell, but it‚Äôs really useless. We expected to have the GNU hello world build inputs available in PATH, including GNU make, but it‚Äôs not the case.</p>
<p>But, we have the environment variables that we set in the derivation, like <code>$baseInputs</code>, <code>$buildInputs</code>, <code>$src</code> and so on.</p>
</blockquote>
<p>Innnnteresting. I didn‚Äôt really think about the <code>PATH</code> thing before. I guess this is something <code>mkShell</code> gives me? No; looking back on the source, it must be something the standard environment‚Äôs <code>shellHook</code> thing?</p>
<p>Hmm.</p>
<p>I feel like this chapter is‚Ä¶ not a good intro for a beginner. This is not a good first ‚Äúhow to use Nix.‚Äù But it‚Äôs a very good ‚ÄúI‚Äôve used Nix a bit, and now I want to go in deeper.‚Äù</p>
<p>Anyway, thinking about how little <code>nix-shell</code> actually does makes it <em>even weirder</em> to me that it executes <code>bash</code>. Like, the more generic version of <code>nix-shell</code> is to just execute a <em>different builder</em> with the same environment. Let me pick the builder. It‚Äôs already separate in the <code>drv</code> file, right?</p>
<p>Hmm.</p>
<h1 id=chapter-11-garbage-collector>Chapter 11. Garbage Collector</h1>
<p>Doesn‚Äôt really add anything over the manual. Talks about adding roots, and indirect roots. No mention of <code>keep-outputs</code>. I didn‚Äôt learn anything from this chapter.</p>
<h1 id=chapter-12-inputs-design-pattern>Chapter 12. Inputs Design Pattern</h1>
<p>This chapter is‚Ä¶ motivating the idea of making packages take their inputs as function arguments?</p>
<p>This is something that seems so natural to me I wouldn‚Äôt have thought to motivate it. But starting from first principles, it is an invention, I guess?</p>
<p>I dunno.</p>
<h1 id=chapter-13-callpackage-design-pattern>Chapter 13. Callpackage Design Pattern</h1>
<p><code>callPackage</code>. It seems a little odd to call this a ‚Äúdesign pattern,‚Äù just as it felt odd to call‚Ä¶ functions a design pattern. It‚Äôs a pattern! It‚Äôs‚Ä¶ I don‚Äôt know what ‚Äúdesign pattern‚Äù means in this day and age, I suppose.</p>
<blockquote>
<p>We renamed the old <code>pkgs</code> of the previous pill to <code>nixpkgs</code>. Our package set is now instead named <code>pkgs</code>. Sorry for the confusion.</p>
</blockquote>
<p>This shouldn‚Äôt really‚Ä¶ hmm. That‚Äôs a weird thing to keep in the ‚Äúofficial‚Äù mirror of this post. Maybe these chapters haven‚Äôt actually changed since the original publication?</p>
<p>Anyway. <code>callPackage</code>. I‚Äôve seen it.</p>
<h1 id=chapter-14-override-design-pattern>Chapter 14. Override Design Pattern</h1>
<p>We walk through an implementation of the <code>override</code> ‚Äúmethod.‚Äù I don‚Äôt really get this. It seems straightforward to me, but I guess that if you‚Äôre used to object-oriented languages, it might be weird?</p>
<h1 id=chapter-15-nix-search-paths>Chapter 15. Nix Search Paths</h1>
<p>Explains <code>NIX_PATH</code> and <code>.nix-defexpr</code>. I dunno; this is valuable information, but it also seems like something that you‚Äôve probably already encountered if you made it 15 chapters into this guide. Maybe not! But I dunno. Since we‚Äôve only really talked about writing <code>default.nix</code> files, and not really using <code>nix-env</code> yet, I guess maybe it makes sense to introduce it this late. But the order is not really‚Ä¶ I dunno. Seems weird.</p>
<h1 id=chapter-16-nixpkgs-parameters>Chapter 16. Nixpkgs Parameters</h1>
<blockquote>
<p>I‚Äôm sure on the wiki or other manuals you‚Äôve read about <code>~/.nixpkgs/config.nix</code> and I‚Äôm sure you‚Äôve wondered whether that‚Äôs hardcoded in nix. It‚Äôs not, it‚Äôs in nixpkgs.</p>
</blockquote>
<p>Huh. Mine is <code>~/.config/nixpkgs/config.nix</code>. I‚Äôm sure this looks at a million possible files. This section links to a source line in the Nixpkgs repo, but not a specific revision, so of course it refers to something nonsensical now.</p>
<p>I‚Äôm not sure if the Nix Pills source lives in the Nixpkgs repo or the Nix repo or what, but keeping this up to date seems silly. Anyway; here‚Äôs <a href=https://github.com/NixOS/nixpkgs/blob/6a882635f23e709968e77b584ca452e04c5a4ee4/pkgs/top-level/impure.nix#L25>the source as it stands right now</a>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=c1># Fallback: The contents of the configuration file found at $NIXPKGS_CONFIG or</span>
<span class=c1># $HOME/.config/nixpkgs/config.nix.</span>
<span class=n>config</span> <span class=o>?</span> <span class=k>let</span>
    <span class=n>configFile</span> <span class=o>=</span> <span class=nb>getEnv</span> <span class=s2>"NIXPKGS_CONFIG"</span><span class=p>;</span>
    <span class=n>configFile2</span> <span class=o>=</span> <span class=n>homeDir</span> <span class=o>+</span> <span class=s2>"/.config/nixpkgs/config.nix"</span><span class=p>;</span>
    <span class=n>configFile3</span> <span class=o>=</span> <span class=n>homeDir</span> <span class=o>+</span> <span class=s2>"/.nixpkgs/config.nix"</span><span class=p>;</span> <span class=c1># obsolete</span>
  <span class=k>in</span>
    <span class=k>if</span> <span class=n>configFile</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile</span>
    <span class=k>else</span> <span class=k>if</span> <span class=n>homeDir</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile2</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile2</span>
    <span class=k>else</span> <span class=k>if</span> <span class=n>homeDir</span> <span class=o>!=</span> <span class=s2>""</span> <span class=o>&amp;&amp;</span> <span class=n>pathExists</span> <span class=n>configFile3</span> <span class=k>then</span> <span class=kn>import</span> <span class=n>configFile3</span>
    <span class=k>else</span> <span class=p>{}</span>
</code></pre></div><p><code># obsolete</code> indeed, I guess.</p>
<p>Okay. That‚Äôs kind of all that‚Äôs in this chapter? Seems a little weird. But it‚Äôs probably motivating, like, the existence of Nixpkgs, if you‚Äôre starting from scratch? But who is starting from that degree of scratch, at this point?</p>
<h1 id=chapter-17-nixpkgs-overriding-packages>Chapter 17. Nixpkgs Overriding Packages</h1>
<p>Talking about ‚Äúthe Nix packages fixpoint‚Äù is actually very useful/interesting. But I don‚Äôt really think the treatment here‚Ä¶ I‚Äôm glad it gives an example of <code>fix</code>, I guess. That‚Äôs useful. That‚Äôs good. I can‚Äôt really judge if this is a useful explanation.</p>
<blockquote>
<p>The fixed point with lazy evaluation is crippling but about necessary in a language like Nix. It lets us achieve something similar to what we‚Äôd do imperatively.</p>
</blockquote>
<p>This is a weird thing to say. It does not explain what we would do imperatively, or what this lets us achieve, or why it‚Äôs crippling. I don‚Äôt understand the sentiment this is trying to convey.</p>
<p>I assume that it means imperatively re-assigning properties of a derivation, in a way such that they propagate to other derivations that reference ours. This how a ‚Äúnormal‚Äù imperative language with reference semantics would work. It doesn‚Äôt say that, though, or really explain why this is equivalent. So, I don‚Äôt know.</p>
<blockquote>
<p>Whereas in an imperative setting, like with other package managers, a library is installed replacing the old version and applications will use it, in Nix it‚Äôs not that straight and simple. But it‚Äôs more precise.</p>
</blockquote>
<p>I very mildly object to this statement. I think it‚Äôs true; I just think it deserves some justification. The does not really try to substantiate this claim. Anyway. This isn‚Äôt interesting.</p>
<p>Okay.</p>
<p>I don‚Äôt <em>know</em> if what I‚Äôm about to say is true, but I don‚Äôt <em>think</em> that this chapter did a very good job of explaining <em>how</em> overrides work to someone who doesn‚Äôt already have a good idea of how they work.</p>
<p>It tries more than the official manual does to explain what‚Äôs going on, but I have a feeling the explanation here would leave a newcomer to lazy evaluation more confused than when they started. Or maybe not! I‚Äôm a terrible judge of this now.</p>
<h1 id=chapter-18-nix-store-paths>Chapter 18. Nix Store Paths</h1>
<blockquote>
<p>The way store paths are computed is a little contrived, mostly due to historical reasons. Our reference will be the Nix source code.</p>
</blockquote>
<p>Okay. This seems‚Ä¶ not super important to know.</p>
<blockquote>
<p>Finally the comments tell us to compute the base-32 representation of the first 160 bits (truncation) of a sha256 of the above string</p>
</blockquote>
<p>Ah. Maybe this is why my ‚Äúconvert this hash to base32‚Äù thing back in chapter 6 didn‚Äôt work.</p>
<p>Let‚Äôs see‚Ä¶ 160 bits = 20 bytes = 40 hex characters, so‚Ä¶</p>
<pre><code>$ nix to-base32 --type sha256 6339694dbeb706c5097180ed1d79b2dae681bf15
error: hash '6339694dbeb706c5097180ed1d79b2dae681bf15' has wrong length for hash type 'sha256'
</code></pre>
<p>Well, yeah, of course it does, but‚Ä¶ can‚Äôt you just, like, do a base conversion of a number? Why‚Ä¶ what?</p>
<p>Anyway; paying more attention to the contents of this chapter, this wouldn‚Äôt have worked anyway, because the hash we‚Äôre talking about is not the hash of the contents but rather the hash of a string containing the contents. Okay?</p>
<p>My eyes glaze over; I do not understand why it is important to know precisely where these hashes come from. This chapter has not motivated <em>why</em> it‚Äôs explaining this, and I am having a hard time coming up with a reason.</p>
<p>Ah, here we go: it walks through a concrete example of a fixed-output derivation. And I learn the <code>--truncate</code> flag to <code>nix hash</code>. Which lets me get all the way there:</p>
<pre tabindex=0><code>$ nix-shell -p coreutils

[nix-shell:~]$ nix-hash --type sha256 --base32 --truncate --flat &lt;(printf 'output:out:sha256:%s:/nix/store:pcre-ocaml-7.2.3.tar.gz' $(echo
 -n 'fixed:out:sha256:6339694dbeb706c5097180ed1d79b2dae681bf155a4780a7909af49b0
e6f4666' | sha256sum | cut -d' ' -f1))
r24wj6nsw3s9sli2wkfj6nb2rmzr2gbw
</code></pre><p>No. Still not right. Okay. I have exhausted my ability to care. But theoretically, this chapter is telling me that fixed-output paths really are content-addressable. It‚Äôs just a weird and convoluted address. Okay.</p>
<p>And that was the whole chapter. Interesting. I mean, it <em>is</em> interesting, to me, how this works, but this is like‚Ä¶ this is a deep cut, here. This is not something that anyone needs to know, in order to use Nix. Probably not even to contribute to Nix. This is like‚Ä¶ something you can figure out, if you ever actually care. I mean, I recognize that that‚Äôs probably what this chapter is: the author wanting to understand this. But for a newcomer‚Äôs guide to Nix, this feels pretty unnecessary.</p>
<p>Although‚Ä¶ is that the intent of the Nix Pills series? Is this supposed to be a newcomer‚Äôs guide? Or did this begin something like my weird series, a chronicle of an the author following the fun, that has since morphed into recommended reading?</p>
<p>I cannot know.</p>
<h1 id=chapter-19-fundamentals-of-stdenv>Chapter 19. Fundamentals of Stdenv</h1>
<blockquote>
<p>Remember our generic <code>builder.sh</code> in Pill 8? It sets up a basic <code>PATH</code>, unpacks the source and runs the usual autotools commands for us.</p>
<p>The <code>stdenv</code> <code>setup</code> file is exactly that. It sets up several environment variables like <code>PATH</code> and creates some helper bash functions to build a package. I invite you to read it, it‚Äôs only 860 lines at the time of this writing.</p>
</blockquote>
<p>It is now 1,338 lines long, but, you know, whatever. It‚Äôs long. It‚Äôs complicated. I looked through it, as a new Nix user, and got very little out of it. Perhaps you will get more out of it? I don‚Äôt know. I feel like I get the gist, now, and don‚Äôt look through it again.</p>
<p>And here comes the reveal: that the builders we were writing in previous chapters were <em>secretly</em> building up to <code>stdenv/setup</code> all along. That‚Äôs sort of all of the information here. It‚Äôs a strange presentation order. This is a pretty hard downshift from ‚Äúimplementation details of Nix‚Äôs hashing algorithm.‚Äù</p>
<h1 id=chapter-20-basic-dependencies-and-hooks>Chapter 20. Basic Dependencies and Hooks</h1>
<p>This chapter begins with a pleasant introduction, followed by this concerning note:</p>
<blockquote>
<aside>
Note: The complexity of the dependencies and hooks infrastructure has increased, over time, to support cross compilation.
</aside>
</blockquote>
<p><em>Has it ever</em>.</p>
<blockquote>
<aside>
Once you learn the core concepts, you will be able to understand the extra complexity. As a starting point, you might want to refer to nixpkgs commit <code>6675f0a5</code>, the last version of stdenv without cross-compilation complexity.
</aside>
</blockquote>
<p>That is probably a very interesting diff to read, actually. Of course I don‚Äôt care about <code>6675f0a5</code>, I care about the ‚Äúchild‚Äù commits, which is‚Ä¶ how do you see that? That is definitely not something I could recite off the top of my head. The internet tells me:</p>
<pre><code>$ git log 6675f0a5..HEAD --ancestry-path --reverse
</code></pre>
<p>To see the commits made after that. Why is <code>--ancestry-path</code> required? I don‚Äôt know. I tried to look at the explanation in <code>man git-log</code> and just‚Ä¶ wow.</p>
<blockquote>
<p>Suppose you specified <code>foo</code> as the <code>&lt;paths&gt;</code>. We shall call commits that modify <code>foo</code> <code>!TREESAME</code>, and the rest <code>TREESAME</code>. (In a diff filtered for <code>foo</code>, they look different and equal, respectively.)</p>
</blockquote>
<p>I spent five minutes trying to figure out what that parenthetical is trying to tell me, but I have given up.</p>
<p>Anyway. That does show the commits that introduce the cross-compilation <em>stuff</em>, but I don‚Äôt actually bother reading the diff. Seems‚Ä¶ enormously complicated.</p>
<p>Okay so. What are we doing here? Reading chapter 20. Okay.</p>
<p>We learn about <code>buildInputs</code>. It explains the bash function <code>findInputs</code> in the <code>stdenv/setup</code> script, which adds the <code>bin/</code> directories of our <code>buildInputs</code> to our <code>PATH</code>. It walks through some code that does that, although it‚Äôs exactly the code you‚Äôd expect.</p>
<p>Next we learn <code>propagatedBuildInputs</code>. This is something I sort of remember learning about, maybe in the Nixpkgs manual, but it was in the extremely complicated cross-compilation section, and I could not actually tell you what it‚Ä¶ is. Maybe it was explained well, and I‚Äôve just forgotten? But I do not remember.</p>
<p>The chapter gives a very good explanation, though:</p>
<blockquote>
<p>The <code>buildInputs</code> covers direct dependencies, but what about indirect dependencies where one package needs a second package which needs a third? Nix itself handles this just fine, understanding various dependency closures as covered in previous builds. But what about the conveniences that <code>buildInputs</code> provides, namely accumulating in <code>pkgs</code> environment variable and inclusion of <code>pkg/bin</code> directories on the <code>PATH</code>? For this, <code>stdenv</code> provides the <code>propagatedBuildInputs</code>.</p>
</blockquote>
<p>This is interesting: it describes that this works by actually creating files in the <code>out</code> path, in a special <code>nix-support</code> subdirectory.</p>
<pre><code>$ find /nix/store -name 'nix-support'
(thousands of results)

$ cd /nix/store/m9n29mydxdjvjqj7rw9idwiqhm2bww1d-ghc-8.10.4/nix-support

$ ls
propagated-build-inputs
propagated-target-target-deps

$ cat propagated-build-inputs
/nix/store/47vpv5i10dwfg1cf5wca1k40f982g5fm-clang-wrapper-7.1.0

$ cat propagated-target-target-deps
/nix/store/dy2rb80nvksrcsbm4hggvayzdv8fwvhx-ncurses-6.2 /nix/store/3068jzr60jjd3xagmly4b06nh5kcb0cs-libffi-3.3 /nix/store/w6iysk0w7j8qnzljp8467yw03ppq3bvk-gmp-6.2.1 /nix/store/4gngk4048zq7fcyx9959vhv09pwy4d6h-libiconv-50
</code></pre>
<p>Interesting! So basically, the output path now references on these other packages. We can think of these as being promoted to ‚Äúruntime‚Äù dependencies, although we recognize that Nix does not think in terms like that.</p>
<p>More importantly, the contents of these files can be read back by the <code>stdenv</code> script, such we don‚Äôt <em>just</em> put <code>buildInputs</code> in our <code>PATH</code>, but also each of these dependencies, and so on recursively. You get it. I don‚Äôt need to explain this.</p>
<blockquote>
<p>in general, a dependency might affect the packages it depends on in arbitrary ways. <em>Arbitrary</em> is the key word here. We could teach <code>setup.sh</code> things about upstream packages like <code>pkg/nix-support/propagated-build-inputs</code>, but not arbitrary interactions.</p>
<p><em>Setup hooks</em> are the basic building block we have for this. In nixpkgs, a ‚Äúhook‚Äù is basically a bash callback, and a setup hook is no exception.</p>
</blockquote>
<p>Okay. I <em>do</em> remember setup hooks, as basically allowing packages to do things to packages that depend on them. So like, yeah, propagating dependencies is a specific case of this, right? That could be implemented as a setup hook. But it‚Äôs special-cased by <code>stdenv/setup</code>.</p>
<blockquote>
<p>One can almost think of this as an escape hatch around Nix‚Äôs normal isolation guarantees, and the principle that dependencies are immutable and inert. We‚Äôre not actually doing something unsafe or modifying dependencies, but we are allowing arbitrary ad-hoc behavior. For this reason, <code>setup-hooks</code> should only be used as a last resort.</p>
</blockquote>
<p>I don‚Äôt‚Ä¶ follow this reasoning at all. An ‚Äúescape hatch around ‚Ä¶ the principle that dependencies are immutable and inert.‚Äù I mean, they‚Äôre still immutable and inert, right? We didn‚Äôt escape that. In no way can this mutate a dependency. And the dependency itself isn‚Äôt doing anything; we‚Äôre <em>choosing</em> to search for these <code>setup-hook</code> files and run them. This is something we could choose not to do, if we didn‚Äôt want to.</p>
<p>I dunno; this doesn‚Äôt seem like a ‚Äúlast resort‚Äù thing. It seems like a useful tool to have when you need it. Anyway.</p>
<p>Lastly, we learn about environment hooks. So basically‚Ä¶ we find every (direct or ‚Äúpropagated‚Äù) dependency. And every time we find a dependency, we <em>source</em> its <code>setup-hook</code> file, if it exists. And each <code>setup-hook</code> may or may not register ‚Äúenvironment‚Äù hooks.</p>
<p>Once we‚Äôve done that for every package, we go through and add each one to our <code>PATH</code>, if it has a <code>bin/</code> directory. And then we invoke every ‚Äúenvironment hook‚Äù that we have so far ‚Äì basically, the union of ‚Äúenvironment hooks we explicitly defined‚Äù and ‚Äúenvironment hooks registered by our dependencies' <code>setup-hook</code>s.‚Äù</p>
<p>So every dependency gets a chance to see every other dependency, basically.</p>
<p>Why?</p>
<p>The introduction to this section motivated this, before explaining what it was:</p>
<blockquote>
<p>Recall in Pill 12 how we created <code>NIX_CFLAGS_COMPILE</code> for <code>-I</code> flags and <code>NIX_LDFLAGS</code> for <code>-L</code> flags, in a similar manner to how we prepared the <code>PATH</code>.</p>
</blockquote>
<p>I don‚Äôt really remember that because I was kind of‚Ä¶ skimming, if we‚Äôre being honest. Chapter 12 seemed boring.</p>
<blockquote>
<p>One point of ugliness was how anti-modular this was. It makes sense to build the <code>PATH</code> in generic builder, because the <code>PATH</code> is used by the shell, and the generic builder is intrinsically tied to the shell. But <code>-I</code> and <code>-L</code> flags are only relevant to the C compiler. The <code>stdenv</code> isn‚Äôt wedded to including a C compiler (though it does by default), and there are other compilers too which may take completely different flags.</p>
</blockquote>
<p>That makes sense. So basically, the derivation for <code>gcc</code> has a <code>setup-hook</code> which registers an <em>environment hook</em> which accumulates include paths to eventually pass as <code>-I</code>. Neat. Okay.</p>
<p>That‚Äôs the end!</p>
<p>That‚Äôs the end of Nix Pills series. It actually has a ‚Äúcoming soon‚Äù teaser at the bottom for the ‚ÄúNext pill,‚Äù as every chapter has so far:</p>
<blockquote>
<p>‚Ä¶I‚Äôm not sure! We could talk about the additional dependency types and hooks which cross compilation necessitates, building on our knowledge here to cover stdenv as it works today. We could talk about how nixpkgs is bootstrapped. Or we could talk about how <code>localSystem</code> and <code>crossSystem</code> are elaborated into the <code>buildPlatform</code>, <code>hostPlatform</code>, and <code>targetPlatform</code> each bootstrapping stage receives. Let us know which most interests you!</p>
</blockquote>
<p>It‚Äôs a shame that the series ended there, because I feel like the author of the Pills could probably explain the cross-compilation stuff more clearly than the Nixpkgs manual did.</p>
<h1 id=we-did-it>We did it</h1>
<p>There we have it! I read the Pills. I know the things, now.</p>
<p>I learned some good stuff. It was definitely not completely redundant with the Nix and Nixpkgs manuals, and I felt that last chapter especially gave a nice treatment of a part of the <code>genericBuilder</code> that was a <em>little</em> buried in the Nixpkgs manual. Or that I just forgot about. And 6 and 7 were just great introductions to defining your own derivation. I <em>think</em>. Hard to really judge, at this point.</p>
<p>Phew. That was a long one. Why did I do this in a single post? Why didn‚Äôt I break this up? What was I thinking?</p>
<hr>
<ul>
<li>Why does the repl instantiate <code>.drv</code> files and put them into the actual store?</li>
<li>Is there anything Nix-specific about NAR files?</li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>Something about the lack of attribution and collaborative nature of the Nix and Nixpkgs manual made it easy for me to criticize, even though I do realize there are real people with real feelings who wrote those also. I hope that I haven‚Äôt been being mean without thinking about it this entire time.&nbsp;<a href=#fnref:1 class=footnote-backref role=doc-backlink>‚Ü©Ô∏é</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>I would never, <em>ever</em> snuggle my operands in actual code, but I could see myself lazily typing that at a repl.&nbsp;<a href=#fnref:2 class=footnote-backref role=doc-backlink>‚Ü©Ô∏é</a></p>
</li>
</ol>
</section></div>
</article>
<div class=post-footer>
<a href="mailto:ianthehenry@gmail.com?subject=let%27s%20talk%20about%20%22Nix%20Pills%22&amp;body=First%20of%20all,%20I%20just%20wanted%20to%20say%20that%20I%20forgive%20you%20for%20not%20having%20a%20real%20comment%20system%20on%20your%20site.">comment on this post</a><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>Next up ‚ûú How to install Python</a></div>
<aside class=series-rider>
<p>
This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>.
You can
<a target=_blank href=https://ianthehenry.com/feed.xml>subscribe to my RSS feed</a>
or
<a target=_blank href=https://twitter.com/ianthehenry>follow me on Twitter</a>
for more, or <a href=https://ianthehenry.com/posts/>peruse my back catalog</a> if you're in the mood for something different.
<div class=subsection-header>Opening remarks</div><ol start=1 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/introduction/>What's all this about?</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/prior-knowledge/>Prior knowledge</a></li>
</ol><div class=subsection-header>Reading the Nix manual</div><ol start=3 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/glossary/>What we talk about when we talk about Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>Quick starts, full hearts</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/basic-package-management/>Basic package management</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/profiles/>Profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/garbage-collection/>Garbage collection</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/channels/>Channels</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/sharing/>Learning to share</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>My first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Okay my actual first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>The Nix expression language</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations/>Derivations</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>Built-in Functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/advanced-topics/>Advanced Topics</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>Command Reference</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/configuration/>Configuration</a></li>
</ol><div class=subsection-header>Interlude: in which we follow our hearts, however briefly</div><ol start=18 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-manual-reflection/>So I read the manual huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/>Switching from Homebrew to Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-nix-bug/>My first Nix bug</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-package-upgrade/>My first package upgrade</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Setting up a declarative user environment</a></li>
</ol><div class=subsection-header>Reading the Nixpkgs manual</div><ol start=23 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/>How to learn Nixpkgs</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>Overlays</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>Overriding</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>An infinite list of functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Even more functions, somehow</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/the-standard-environment/>The standard environment</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>Derivations in detail</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/cross-compilation/>Cross-compilation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/platform-notes/>Platform notes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>Builders</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/languages-and-frameworks/>Languages and frameworks</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/random-package-grab-bag/>Random package grab-bag</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-give-back/>How to give back</a></li>
</ol><div class=subsection-header>Documentation behind us, we set out on our own</div><ol start=36 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nixpkgs-reflection/>So I read the other manual, huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>Saving your shell</a></li>
</ol><div class=subsection-header>Oh right forgot about Nix Pills</div><ol start=38 class=post-list><li><strong><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Nix Pills</a></strong>&nbsp;‚Üê&nbsp;you are here</li>
</ol><div class=subsection-header>Our whole lives ahead of us</div><ol start=39 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>How to install Python</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/open-questions/>Open questions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/ambiguous-packages/>Ambiguous packages</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Running zsh in nix-shell</a></li>
</ol><div class=subsection-header>Nix 2.4 slithers to life</div><ol start=43 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/flakes/>My first brush with flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/more-flakes/>More flakes, unfortunately</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/new-profiles/>Fancy new profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/chipping-away-at-flakes/>Chipping away at flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-develop/>New and unimproved shells</a></li>
</ol>
</aside>
</main>
<footer>
¬© 1899-1907 <a href=https://ianthehenry.com/about/>Ian Henry</a>
</footer>
