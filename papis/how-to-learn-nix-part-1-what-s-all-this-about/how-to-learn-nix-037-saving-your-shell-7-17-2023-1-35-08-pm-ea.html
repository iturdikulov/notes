<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/ 
 saved date: Mon Jul 17 2023 13:35:08 GMT+0600 (Kyrgyzstan Time)
--><meta charset=utf-8>
<meta name=viewport content="initial-scale=1,maximum-scale=1">
<title>How to Learn Nix, Part 37: Saving your shell</title>
<link rel=canonical href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>
<style>:root{--box-radius:6px;--outer-box-radius:10px}:root{--content-bg:#fff;--gutter-bg:#eeeef3;--text-fg:#4d4d4c;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:#07c;--link-visited:#751a9a;--blockquote-accent:var(--link);--footnote-accent:#ffd2a3;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#34b553;--media-controls-contrast:#fff;--inline-code-bg:#f3f3fa;--code-block-bg:#f3f3fa;--aside-bg:#f3f3fa;--aside-warning-bg:#fff5d1;--aside-warning-fg:#ac3233;--palette-red:#c82829;--palette-green:#718c00;--palette-yellow:#eab700;--palette-orange:#f5871f;--palette-blue:#4271ae;--palette-purple:#8959a8;--palette-teal:#3e999f;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#8e908c;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--text-fg)}#dmt::before{content:"ğŸŒ–"}#dmt:hover::before{content:"ğŸŒ—"}@media (prefers-color-scheme:dark){:root:not(.light-theme){--content-bg:#313233;--gutter-bg:#1d1f21;--text-fg:#d8d4cf;--table-border-color:#ccc;--separator-color:#6d6d6c;--link:rgb(82,183,255);--link-visited:rgb(193,104,229);--blockquote-accent:var(--link);--footnote-accent:#a8612f;--subscribe-button-bg:#44e66c;--subscribe-button-fg:#11391b;--media-controls-on:#44e66c;--media-controls-contrast:#11391b;--inline-code-bg:#3c4044;--code-block-bg:#1d1f21;--aside-bg:#3c4044;--aside-warning-bg:#fff5d1;--aside-warning-fg:var(--palette-red);--palette-red:#cc6666;--palette-green:#b5bd68;--palette-yellow:#f0c674;--palette-orange:#de935f;--palette-blue:#81a2be;--palette-purple:#b294bb;--palette-teal:#8abeb7;--palette-white:#fefefe;--palette-black:#000;--palette-text:var(--text-fg);--palette-dim:#969896;--highlight-bg:var(--palette-yellow);--highlight-fg:var(--palette-black)}:root:not(.light-theme) #dmt::before{content:"ğŸŒ’"}:root:not(.light-theme) #dmt:hover::before{content:"ğŸŒ“"}}#dmt{width:30px;text-align:right;padding-right:4px;position:absolute;top:0;bottom:0;right:0;border:none;background-color:inherit;cursor:pointer}*{margin:0;padding:0;font:inherit;box-sizing:border-box}html{background-color:var(--gutter-bg);color:var(--text-fg)}body{font-family:system-ui,sans-serif;font-size:12pt;line-height:1.8;word-wrap:break-word}body:not(.content-page) main>aside{padding:0 var(--content-padding)}body.content-page main,body:not(.content-page) article{background-color:var(--content-bg);border-radius:var(--outer-box-radius);padding:var(--content-padding)}pre{word-wrap:normal}em,i{font-style:italic}sup{font-size:75%}sup a::before{content:"["}sup a::after{content:"]"}h1>a:only-child,h2>a:only-child{display:block}main .subsection-header+.post-list{margin-top:0}strong{font-weight:700}ol,ul{padding-left:3ch}.footnotes>ol{margin-top:1em}.footnotes li:not(.highlight){transition:background-color 1s}hr{border-style:solid;border-width:1.5px 0 0;border-radius:1px;border-color:var(--separator-color)}:not(pre)>code{white-space:pre;background-color:var(--inline-code-bg)}li{padding-left:0}blockquote{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none}a,a:active,a:visited{text-decoration:none}a:hover{text-decoration:underline}blockquote{padding:0 0 0 var(--content-padding);border-left:solid 2px var(--blockquote-accent)}aside{--content-padding:0.5em;padding:.5em;border-radius:var(--box-radius);background-color:var(--aside-bg)}a,a:active,header a:visited,footer a:visited,h1 a:visited{color:var(--link)}a:visited{color:var(--link-visited)}a.footnote-ref:visited,a.footnote-backref:visited,.notation-help-link-container a:visited{color:var(--link)}h1{font-size:130%}main *+p,main *+pre,main *+aside,main *+section,main *+article,main *+blockquote,main *+div,main *+ul,main *+hr,main *+h1{margin-top:1em}main .post-header *+h1{margin-top:0}code{font-family:Menlo,monospace;padding:0 3px;border-radius:2px}pre{background-color:var(--code-block-bg);font-size:11pt;padding:calc(.75*var(--content-padding)) var(--content-padding);line-height:1.3;border-radius:var(--box-radius);overflow-x:scroll;-webkit-overflow-scrolling:touch}pre code{padding:0;border-radius:0;display:inline-block;background-color:initial}p+p{margin-top:1em}body{margin:0 auto;--content-padding:10px;max-width:768px;-webkit-text-size-adjust:100%;position:relative}header{position:relative}header>*{height:48px;line-height:48px}.promo,.promo:visited,.promo:active{display:block;text-align:center;background-color:var(--link);color:var(--code-block-bg);border-radius:0 0 var(--outer-box-radius) var(--outer-box-radius)}header .site-title{font-size:130%}header nav{position:absolute;right:30px;top:0}@media all and (max-width:400px){:root{--outer-box-radius:0}header{text-align:center}header nav{position:static}:not(pre)>code{white-space:pre-wrap}body{--content-padding:10px}#dmt{padding:0;text-align:center;width:40px}}header ul{padding:0}header li{list-style:none;display:inline-block}header a{display:block;height:100%}header li+li{margin-left:1em}footer{padding:2em 0;font-size:.85em;text-align:center}article h1.post-title{font-size:200%}article .post-title a{display:block}article .meta{font-size:90%;font-style:italic}.post-header h1{line-height:1.2em;margin-bottom:.5em}.post-footer{text-align:center}.post-footer a{display:block}ol.post-list{list-style-position:inside;padding:0}.series-rider .series-name{font-style:italic}.highlight{color:var(--palette-text)}.highlight .n{color:var(--palette-text)}.highlight .o{color:var(--palette-teal)}.highlight .p{color:var(--palette-text)}.highlight .s2{color:var(--palette-green)}.highlight .se{color:var(--palette-orange)}.highlight .s1{color:var(--palette-green)}</style>
<meta property=og:title content="How to Learn Nix, Part 37: Saving your shell">
<meta property=og:type content=website>
<meta property=og:url content=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>
<meta name=description content="One of my very first open questions, all the way back in the quick start guide, was this:

How do I collect garbage without making my next invocation of nix-shell -p hello redownload all the stuff it needs to be a shell?

Since the time I wrote that question, a lot has changed. I read the entire Nix manual. I read the entire Nixpkgs manual. Iâ€™ve been using Nix for months.
And I still have no idea what the answer is.">
<meta property=og:description content="One of my very first open questions, all the way back in the quick start guide, was this:

How do I collect garbage without making my next invocation of nix-shell -p hello redownload all the stuff it needs to be a shell?

Since the time I wrote that question, a lot has changed. I read the entire Nix manual. I read the entire Nixpkgs manual. Iâ€™ve been using Nix for months.
And I still have no idea what the answer is.">
<meta property=og:image content=https://ianthehenry.com/checkerboard.png>
<meta name=twitter:creator content=@ianthehenry>
<meta name=twitter:card content=summary>
<link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAHH1uIDShg/xEsZv8GFk3/CSJb/wgZT/8IGU//CBlP/wkiW/8HGE7/CBlP/wkiW/8HIFX/BxhO/wcgVf8OK2t7JDhz/wcfW/8NNn7/CSpq/wkjYf8MJGP/DCJg/w02ef9SqdX/TKHJ/1my2f9Moc3/UqzV/1Cr1v9Pocf/Ditr/xk2cf8KJGL/CjR8/wwva/8RK2r/Cido/w8qa/8LLW//TqjT/1Gnz/9bsNf/Sp/K/1Wt2f9Wrtj/UKjQ/w8xc/8gPHj/Di5w/xk4ef8TL27/Dy5u/xU3fv8QLGv/Ditr/1qy3f9dttv/Yrje/0ecx/9Knsz/U6fQ/1m13f8YN3n/JjZx/wszdv8YOXz/Eilm/xc3e/8dSZT/GDJz/xk/hv9hu+P/WbHZ/1mv1v9Kn8z/WLHd/1212v9ds9n/Eipr/xcqYv8SOX3/GzRz/xQrZ/8aM3D/HEuU/xc0df8fPYD/Yrre/1603P9dt9z/VKvY/1iz4v9etNr/Y73m/xk5fP8cMm3/JEWK/xc0dP8eO3v/Hjd4/ydRnP8WM3P/Gjd3/2bA5/9dtd//Ybng/2K95v9ct+P/Ybnf/2K95/8oS5L/GChg/xxBh/8lSIz/GC5s/yM5ev8hRoz/HTp7/yE6e/9Zsdz/YLzn/2jF7v9ryfL/YLzn/1qu1f9htdz/GDyD/y0/ev9qx/X/acDn/1235v9euun/Yb3r/1665v9owu7/GUOL/yhGh/8nUJL/MkmI/yBFiP8jOHb/MVag/yM+gv8VMGv/acXx/27G7/9szv3/bMb1/2zD6/9vy/X/edf5/yBHjv8yS47/JEuO/zVLiv8nS5D/LkOB/yRXpP8lQoT/H0WI/3fS+P910Pf/b8/8/2bB7/991Pn/eNb+/3nT+P8pS5L/O1GS/ytUnP86UJH/NF2k/zNLjP8sXKv/JkCB/x4+ff+B2/3/etT9/4He//922f//fNf//3TT//991/7/NU6N/zZSkP86Zav/PlWR/zFepv88ZKb/MF2n/yQ/gf8bNXH/fd3//3/b//+K6P//ft///3vV//993f//gdz//0hWlf9FZKX/RmOj/0JXlv9IeMP/QXKz/0Jsuf8eO3z/Hjt2/3vd//+C3v//ju3//3zg//+H4v//guL//4nj//9HXp3/UGur/ztgqf9JYqP/S3G4/05ur/9EbLT/Hjt7/zNJhf+G4///heT//4rq//+E5///iOT//4jr//+G4///UXO0/09iov9EX6H/SWWn/1V5wP9Kaa7/RGSp/ydLj/8NKGCfDShg/x8+d/8RLGb/CBlP/wYWTf8GFEj/CBNH/wooZP8JIlv/CCJd/woWSf8HGE7/ByBV/wwgU/8fO3mfAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body class=content-page>
<a class=promo href=https://janet.guide/ target=_blank><i>psst, hey kid, wanna read a weird programming book</i></a>
<header>
<a class=site-title href=https://ianthehenry.com/>Ian Henry</a>
<nav>
<ul><li><a href=https://ianthehenry.com/about/>About</a><li><a href=https://ianthehenry.com/posts/>Blog</a><li><a href=https://ianthehenry.com/stuff/>Stuff</a></ul>
</nav>
<button id=dmt title="Toggle dark mode"></button>
</header>
<main>
<aside class=series-rider>
<p>This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>, a rambling diary in which I work my way through the Nix manual in excrutiating detail.</p>
</aside>
<article class=post>
<div class=post-header>
<time class=meta datetime=2021-05-20>May 20, 2021</time>
<h1 class=post-title>
<a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>How to Learn Nix, Part&nbsp;37:<br>Saving your shell</a></h1>
</div>
<div class=post-content><p>One of my <a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>very first open questions</a>, all the way back in the quick start guide, was this:</p>
<blockquote>
<p>How do I collect garbage without making my next invocation of <code>nix-shell -p hello</code> redownload all the stuff it needs to be a shell?</p>
</blockquote>
<p>Since the time I wrote that question, a lot has changed. I read the entire Nix manual. I read the entire Nixpkgs manual. Iâ€™ve been using Nix for months.</p>
<p>And I still have no idea what the answer is.</p>
<p>Now, I should caveat this a little: I donâ€™t really need to know the answer to <em>this particular question</em>. <code>nix-shell -p</code> is incredibly useful, but I donâ€™t care that much about saying â€œadd whatever is going to be in the standard environment to my GC roots.â€ I mean, thatâ€™s certainly a <em>reasonable</em> thing to say. But I would settle for this more useful question:</p>
<blockquote>
<p>How do I add a <code>shell.nix</code> file to my GC roots?</p>
</blockquote>
<p>And Iâ€™ll sort of wave my hands and assume that that would get me all the same packages as <code>nix-shell -p</code> â€“ which I think is true, as long as my <code>shell.nix</code> used the standard builder. I could then just add a simple empty <code>shell.nix</code> to my GC roots, and it would give me the same thing.</p>
<p>But I donâ€™t know how to do that.</p>
<p>I mean, I remember how to add GC roots: <code>ln -s</code>. But of course that doesnâ€™t work if you just add a symlink to a <code>shell.nix</code> file. Adding a symlink to a <code>shell.nix</code> file does nothing, as a matter of fact.</p>
<p>Which is upsetting, because I <em>want</em> to be able to add a <code>shell.nix</code> file as a GC root. I want that to mean â€œOkay, now when I collect garbage, donâ€™t delete all the things that you need when I run <code>nix-shell</code>.â€</p>
<p>But it doesnâ€™t mean that.</p>
<p>And I get <em>why</em>. GC roots are, after all, for store objects. You canâ€™t just add arbitrary <code>.nix</code> files. <code>.nix</code> files arenâ€™t in the store. Although thatâ€™s certainly the â€œAPIâ€ I <em>expect</em> â€“ the API I want, as that feels very intuitive to me â€“ I understand that it does not actually mesh with my understanding (and the manualâ€™s explanation) of garbage collection. And, you know, it would mean that garbage collection would need to evaluate arbitrary Nix expressions, and youâ€™d have to worry about non-termination during that evaluation, and I understand why itâ€™s not an option.</p>
<p>So, okay. In order to add a â€œshell fileâ€ as a root, we have to do something else. What, exactly?</p>
<p>I have no idea.</p>
<p>Or rather, I <em>had</em> no idea. Spoilers: I already know how to do this, sort of, because I did it, once, in sort of a panic.</p>
<p>I was dangerously close to running out of disk space while working through one of the Nixpkgs chapters, and I needed to collect garbage, but I <em>really</em> didnâ€™t want to have to <a href=https://github.com/qmk/qmk_firmware/blob/3023015c5b9417b18b59be41664e2af8e9f18a79/shell.nix#L36>rebuild GCC from source</a> again. So I googled, and found <a href=https://nixos.wiki/wiki/Storage_optimization#Pinning>a hit on the wiki</a>, which said:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p>
<blockquote>
<p>When you invoke <code>nix-shell</code> with</p>
<pre tabindex=0><code>$ nix-instantiate shell.nix --indirect --add-root $DIR/.nix-gc-roots/shell.drv ...
</code></pre><p>then youâ€™ll have a persistent environment which wonâ€™t be garbage collected. It is useful when you donâ€™t want to spend time waiting for redownloads every time you enter the shell.</p>
<p>A little problem exists though. GC roots are numbered sequentially, so if you change <code>shell.nix</code> to contain <strong>less</strong> derivations, and name of last GC root will start with <code>shell.drv-7</code>, then <code>shell.drv-{8,9,10,11,12}*</code> will be dangling and unused. To overcome this problem you should remove GC roots dir periodically (or just before <code>nix-shell</code>)</p>
</blockquote>
<p>And I will be the first to say: I donâ€™t understand a word of that.</p>
<p>I mean, I get that itâ€™s telling me to run some command. But I donâ€™t understand the command: how does that invoke <code>nix-shell</code>? Grepping my blog tells me that I <em>have</em> run <code>nix-instantiate</code> before, technically, but I couldnâ€™t tell you what it does or why I ran it. I really donâ€™t understand the note about the numbering problem, either.</p>
<p>But I was in a hurry, so I ran the command, even though I didnâ€™t understand it. And guess what? It didnâ€™t work.</p>
<p>And I found out <em>why</em> it didnâ€™t work, eventually, in some comment on some GitHub issue that I didnâ€™t even write down because I was in sort of a rush, and Iâ€™ll get to the missing piece later. But first Iâ€™d like to make this a little more concrete, so I can replay the experience without the same time or space pressure, and see if I can make this make sense to me.</p>
<p>So: in order to add a GC root, we need to add a store object.</p>
<p>That part is simple enough.</p>
<p>So we need to create a store object that represents the â€œresultâ€ of evaluating <code>shell.nix</code>?</p>
<p>But <code>shell.nix</code> is different from, like, <code>default.nix</code>. I understand <code>default.nix</code>. I understand <code>nix-build</code>. I understand running <code>nix-shell</code> with a <code>default.nix</code> and being dropped into a shell containing the dependencies of that <code>default.nix</code>.</p>
<p>I guess that I donâ€™t <em>really</em> understand <code>shell.nix</code> files, then.</p>
<p>Like, theyâ€™re sort ofâ€¦ half of that. Right? Theyâ€™re <em>just</em> a set of dependencies? But they donâ€™t, themselves, represent any derivation. I canâ€™t â€œbuildâ€ a <code>shell.nix</code>. What would it build?</p>
<p>Letâ€™s find out.</p>
<p>I have <a href=https://github.com/ianthehenry/mixologician/blob/f5388cd145a2924550729e524744d06b5ce05de4/shell.nix>a trivial <code>shell.nix</code> file</a> sitting around. If I try to â€œbuildâ€ it:</p>
<pre tabindex=0><code>$ nix-build shell.nix
these derivations will be built:
  /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv
building '/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv'...
nobuildPhase

This derivation is not meant to be built, aborting

builder for '/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv' failed with exit code 1
error: build of '/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv' failed
</code></pre><p>I was expecting that, because I remember this, from <a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>the documentation of <code>mkShell</code></a>:</p>
<blockquote>
<p><code>pkgs.mkShell</code> is a special kind of derivation that is only useful when using it combined with <code>nix-shell</code>. It will in fact fail to instantiate when invoked with <code>nix-build</code>.</p>
</blockquote>
<p>So I expected that to fail, although I never really thought about <em>how</em> when I originally read that. Now that I think about it, it probably defines some trivial derivation, and that derivation checks <code>lib.trivial.inNixShell</code>, and throws an error or something?</p>
<p>Letâ€™s see. I find the source in <code>pkgs/build-support/mkshell/default.nix</code>, and long and short of it is:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=n>stdenv</span><span class=o>.</span><span class=n>mkDerivation</span> <span class=p>({</span>
  <span class=n>name</span> <span class=o>=</span> <span class=s2>"nix-shell"</span><span class=p>;</span>
  <span class=n>phases</span> <span class=o>=</span> <span class=p>[</span><span class=s2>"nobuildPhase"</span><span class=p>];</span>

  <span class=n>buildInputs</span> <span class=o>=</span> <span class=n>mergeInputs</span> <span class=s2>"buildInputs"</span><span class=p>;</span>
  <span class=n>nativeBuildInputs</span> <span class=o>=</span> <span class=n>mergeInputs</span> <span class=s2>"nativeBuildInputs"</span><span class=p>;</span>
  <span class=n>propagatedBuildInputs</span> <span class=o>=</span> <span class=n>mergeInputs</span> <span class=s2>"propagatedBuildInputs"</span><span class=p>;</span>
  <span class=n>propagatedNativeBuildInputs</span> <span class=o>=</span> <span class=n>mergeInputs</span> <span class=s2>"propagatedNativeBuildInputs"</span><span class=p>;</span>

  <span class=n>shellHook</span> <span class=o>=</span> <span class=n>lib</span><span class=o>.</span><span class=n>concatStringsSep</span> <span class=s2>"</span><span class=se>\n</span><span class=s2>"</span> <span class=p>(</span><span class=n>lib</span><span class=o>.</span><span class=n>catAttrs</span> <span class=s2>"shellHook"</span>
    <span class=p>(</span><span class=n>lib</span><span class=o>.</span><span class=n>reverseList</span> <span class=n>inputsFrom</span> <span class=o>++</span> <span class=p>[</span><span class=n>attrs</span><span class=p>]));</span>

  <span class=n>nobuildPhase</span> <span class=o>=</span> <span class=s1>''
</span><span class=s1>    echo
</span><span class=s1>    echo "This derivation is not meant to be built, aborting";
</span><span class=s1>    echo
</span><span class=s1>    exit 1
</span><span class=s1>  ''</span><span class=p>;</span>
<span class=p>}</span> <span class=o>//</span> <span class=n>rest</span><span class=p>)</span>
</code></pre></div><p>Okay. So no; it doesnâ€™t throw, and it doesnâ€™t even check <code>inNixShell</code> â€“ it fails during â€œrealizationâ€ or whatever Nix calls that. Which makes sense, when I think about it: if it threw, then <code>nix-shell</code> probably wouldnâ€™t be able to evaluate its dependencies. This is a nice simpler thing.</p>
<p>So, okay, itâ€™s just a dummy derivation that fails whenever you build it.</p>
<p>Soâ€¦ the question of putting it in the <code>nix-store</code> becomes a tricky one. There is no â€œresultâ€ that we can point to. Except, well, I cheated, so I know that there <em>is:</em> whatever that <code>nix-instantiate</code> command gives us.</p>
<p>So letâ€™s figure out what that does. <code>man nix-instantiate</code> says:</p>
<pre><code>nix-instantiate - instantiate store derivations from Nix expressions
</code></pre>
<p>Basically, this creates <code>.drv</code> files.</p>
<pre tabindex=0><code>$ nix-instantiate shell.nix
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv
</code></pre><p>Okay.</p>
<p>That <code>/nix/store/xxx-nix-shell.drv</code> file is, of course, the same weird internal intermediate representation (??) of a derivation that weâ€™ve seen before, but which has never been explained.</p>
<p>But! I think I know the format of it. It seems to be an â€œATermâ€ file. At least, <code>nix-instantiate</code> makes mention of <code>--json</code> and <code>--xml</code> alternatives to the default ATerm format, and googling â€œaterm expressionsâ€ shows me that, yes, they look like this file. Seems to be short for â€œAnnotated Term,â€ and â€œannotated term formatâ€ <a href=https://strategoxt.org/Tools/ATermFormat>gets a few hits</a> â€“ including a few pretty printers.</p>
<p>But according to <code>nix search</code>, none of these pretty printers are available in Nixpkgs. Meanwhileâ€¦</p>
<pre tabindex=0><code>$ brew info aterm
aterm: stable 2.8 (bottled)
Annotated Term for tree-like ADT exchange
https://strategoxt.org/Tools/ATermFormat
Not installed
From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/aterm.rb
==&gt; Analytics
install: 6 (30 days), 16 (90 days), 72 (365 days)
install-on-request: 3 (30 days), 10 (90 days), 43 (365 days)
build-error: 0 (30 days)
</code></pre><p>But this does not actually contain the <a href=https://www.strategoxt.org/Tools/PpATerm.html><code>pp-aterm</code></a> tool that I want. Sigh.</p>
<p>There is a reference to the <code>strategoxt</code> package in the <em>release notes</em> of Nixpkgsâ€¦ but no such package exists anymore. Nor do I know if it would contain this pretty-printer. And it seems <code>strategoxt</code> has been replaced byâ€¦ an Eclipse plugin? I have no idea, folks.</p>
<p>At this point it might be faster to just write my own pretty-printer for this stupid file format rather than trying to find one.</p>
<p>Sigh, no, I persist:</p>
<pre tabindex=0><code>$ brew tap metaborg/metaborg
...
$ brew install strategoxt
==&gt; Installing strategoxt from metaborg/metaborg
</code></pre><p>Itâ€™s doing stuff. Itâ€™s downloading a lot of things. Itâ€™s downloadingâ€¦ OpenJDK?? Abort. Abort. Nothing is worth this.</p>
<p><em>What did S-expressions ever do to you. Why is this not just an S-expression</em>.</p>
<p>You know, itâ€™s <em>pretty</em> close to oneâ€¦</p>
<pre tabindex=0><code>$ nix-env -iA nixpkgs.ocamlPackages.sexp
... compiling the entire ocaml ecosystem from source, because apparently none of it is cached ...

$ tr ',[]' ' ()' &lt;/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv \
&gt; | xargs -0 -n1 printf '(%s)' \
&gt; | sexp pp
(Derive (
  ((out /nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell "" ""))
  ((/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv (out))
   (/nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drv (out))
   (/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv (out))
   (/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv (out)))
  (/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh)
  x86_64-darwin
  /nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash
  (-e /nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh)
  ((__darwinAllowLocalNetworking "")
   (__impureHostDeps
    "/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh")
   (__propagatedImpureHostDeps "")
   (__propagatedSandboxProfile "")
   (__sandboxProfile           "")
   (buildInputs                "")
   (builder /nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash)
   (configureFlags             "")
   (depsBuildBuild             "")
   (depsBuildBuildPropagated   "")
   (depsBuildTarget            "")
   (depsBuildTargetPropagated  "")
   (depsHostHost               "")
   (depsHostHostPropagated     "")
   (depsTargetTarget           "")
   (depsTargetTargetPropagated "")
   (doCheck                    "")
   (doInstallCheck             "")
   (name                       nix-shell)
   (nativeBuildInputs
    "/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2 /nix/store/axzlbh5ji9pr97mi04f70lizn22bkxj5-python3.9-cram-0.7")
   (nobuildPhase
    "echo\necho \"This derivation is not meant to be built  aborting\";\necho\nexit 1\n")
   (out /nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell)
   (outputs                     out)
   (patches                     "")
   (phases                      nobuildPhase)
   (propagatedBuildInputs       "")
   (propagatedNativeBuildInputs "")
   (shellHook                   "")
   (stdenv /nix/store/59hdixd6qf2jq5mj0bqiwrhy7621wa7j-stdenv-darwin)
   (strictDeps "")
   (system     x86_64-darwin))))
</code></pre><p>There. Screw your stupid format.</p>
<p>I looked at one of these before, long ago, that I manually attempted to pretty-print. I couldnâ€™t make any sense of it. Can I make any sense of this one?</p>
<p>The first few â€œargumentsâ€ to the <code>Derive</code> â€œfunctionâ€ look like â€“ and I am completely guessing here â€“</p>
<pre tabindex=0><code>1. list of outputs...? (no idea about the empty strings)
  ((out /nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell "" ""))

2. map from build-time dependencies to the outputs that require them?
  ((/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv (out))
   (/nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drv (out))
   (/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv (out))
   (/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv (out)))

3. maybe a list of non-derivation build-time dependencies?
  (/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh)

4. system
  x86_64-darwin

5. actual builder executable
  /nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash

6. arguments to the builder
  (-e /nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh)
</code></pre><p>And then the next â€œargumentâ€ reminds me a lot of what you see when you finally coerce <code>nix repl</code> to print out a derivation:</p>
<pre tabindex=0><code>nix-repl&gt; shell = import ./shell.nix

nix-repl&gt; shell
Â«derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drvÂ»

nix-repl&gt; shell // { type = "divination" }
error: syntax error, unexpected '}', expecting ';', at (string):1:32

nix-repl&gt; :p shell // { type = "divination"; }
{ __darwinAllowLocalNetworking = false; __ignoreNulls = true; __impureHostDeps = [ "/bin/sh" "/usr/lib/libSystem.B.dylib" "/usr/lib/system/libunc.dylib" "/dev/zero" "/dev/random" "/dev/urandom" "/bin/sh" ]; __propagatedImpureHostDeps = [ ]; __propagatedSandboxProfile = [ "" ]; __sandboxProfile = ""; all = [ Â«derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drvÂ» ]; args = [ "-e" /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/stdenv/generic/default-builder.sh ]; buildInputs = [ ]; builder = "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash"; configureFlags = [ ]; depsBuildBuild = [ ]; depsBuildBuildPropagated = [ ]; depsBuildTarget = [ ]; depsBuildTargetPropagated = [ ]; depsHostHost = [ ]; depsHostHostPropagated = [ ]; depsTargetTarget = [ ]; depsTargetTargetPropagated = [ ]; doCheck = false; doInstallCheck = false; drvAttrs = { __darwinAllowLocalNetworking = false; __ignoreNulls = true; __impureHostDeps = Â«repeatedÂ»; __propagatedImpureHostDeps = Â«repeatedÂ»; __propagatedSandboxProfile = Â«repeatedÂ»; __sandboxProfile = ""; args = Â«repeatedÂ»; buildInputs = Â«repeatedÂ»; builder = "/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash"; configureFlags = Â«repeatedÂ»; depsBuildBuild = Â«repeatedÂ»; depsBuildBuildPropagated = Â«repeatedÂ»; depsBuildTarget = Â«repeatedÂ»; depsBuildTargetPropagated = Â«repeatedÂ»; depsHostHost = Â«repeatedÂ»; depsHostHostPropagated = Â«repeatedÂ»; depsTargetTarget = Â«repeatedÂ»; depsTargetTargetPropagated = Â«repeatedÂ»; doCheck = false; doInstallCheck = false; name = "nix-shell"; nativeBuildInputs = [ Â«derivation /nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drvÂ» Â«derivation /nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drvÂ» ]; nobuildPhase = "echo\necho \"This derivation is not meant to be built, aborting\";\necho\nexit 1\n"; outputs = [ "out" ]; patches = [ ]; phases = [ "nobuildPhase" ]; propagatedBuildInputs = [ ]; propagatedNativeBuildInputs = [ ]; shellHook = ""; stdenv = Â«derivation /nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drvÂ»; strictDeps = false; system = "x86_64-darwin"; userHook = null; }; drvPath = "/nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv"; inputDerivation = Â«derivation /nix/store/q8smqzbwa9w8aqw2872p1nrb7x98vs78-nix-shell.drvÂ»; meta = { available = true; broken = false; insecure = false; name = "nix-shell"; outputsToInstall = [ "out" ]; position = "/nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/build-support/mkshell/default.nix:28"; unfree = false; unsupported = false; }; name = "nix-shell"; nativeBuildInputs = Â«repeatedÂ»; nobuildPhase = "echo\necho \"This derivation is not meant to be built, aborting\";\necho\nexit 1\n"; out = Â«derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drvÂ»; outPath = "/nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell"; outputName = "out"; outputUnspecified = true; outputs = Â«repeatedÂ»; overrideAttrs = Â«lambda @ /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/stdenv/generic/make-derivation.nix:374:28Â»; passthru = { }; patches = Â«repeatedÂ»; phases = Â«repeatedÂ»; propagatedBuildInputs = Â«repeatedÂ»; propagatedNativeBuildInputs = Â«repeatedÂ»; shellHook = ""; stdenv = Â«repeatedÂ»; strictDeps = false; system = "x86_64-darwin"; type = "divination"; userHook = null; }
</code></pre><p>Well, thatâ€™s kind of a mess, actually, because of the <code>Â«repeatedÂ»</code> business, but it looks like a superset of the final argument to <code>Derive</code> in the <code>.drv</code> file, and I mostly-automatically-but-also-manually get it down to this S-expression, pulling out boring stuff like <code>drvAttrs</code> and <code>meta</code>:</p>
<pre tabindex=0><code class=language-sexp data-lang=sexp>((__darwinAllowLocalNetworking false)
 (__ignoreNulls                true)
 (__impureHostDeps (
   /bin/sh
   /usr/lib/libSystem.B.dylib
   /usr/lib/system/libunc.dylib
   /dev/zero
   /dev/random
   /dev/urandom
   /bin/sh))
 (__propagatedImpureHostDeps ())
 (__propagatedSandboxProfile (""))
 (__sandboxProfile "")
 (all ("Â«derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drvÂ»"))
 (args (
   -e
   /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/stdenv/generic/default-builder.sh))
 (buildInputs ())
 (builder /nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23/bin/bash)
 (configureFlags             ())
 (depsBuildBuild             ())
 (depsBuildBuildPropagated   ())
 (depsBuildTarget            ())
 (depsBuildTargetPropagated  ())
 (depsHostHost               ())
 (depsHostHostPropagated     ())
 (depsTargetTarget           ())
 (depsTargetTargetPropagated ())
 (doCheck        false)
 (doInstallCheck false)
 (drvPath /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv)
 (inputDerivation
  "Â«derivation /nix/store/q8smqzbwa9w8aqw2872p1nrb7x98vs78-nix-shell.drvÂ»")
 (name              nix-shell)
 (nativeBuildInputs Â«repeatedÂ»)
 (nobuildPhase
  "echo\necho \"This derivation is not meant to be built, aborting\";\necho\nexit 1\n")
 (out
  "Â«derivation /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drvÂ»")
 (outPath /nix/store/5i9c80x5h0mjpxwfnj6iz8ykivzjrcyq-nix-shell)
 (outputName        out)
 (outputUnspecified true)
 (outputs           Â«repeatedÂ»)
 (overrideAttrs
  "Â«lambda @ /nix/store/4rvsrjbd2f351zgdh38as0xzwrlmvzkm-nixpkgs-21.05pre287374.1c16013bd6e/nixpkgs/pkgs/stdenv/generic/make-derivation.nix:374:28Â»")
 (passthru ())
 (patches               Â«repeatedÂ»)
 (phases                Â«repeatedÂ»)
 (propagatedBuildInputs Â«repeatedÂ»)
 (propagatedNativeBuildInputs Â«repeatedÂ»)
 (shellHook  "")
 (stdenv     Â«repeatedÂ»)
 (strictDeps false)
 (system     x86_64-darwin)
 (type       divination)
 (userHook   null))
</code></pre><p>Which is <em>pretty close</em> to whatâ€™s in the <code>.drv</code> file.</p>
<p>Oh! You know what this is? That last argument? Those are environment variables!</p>
<p>Yeah. I bet you Iâ€™m right. I donâ€™t <em>know</em> if Iâ€™m right, but Iâ€™d bet you Iâ€™m right, because it makes sense: the <code>.drv</code> file basically contains everything you need in order to â€œbuildâ€ the derivation, and nothing else. And obviously one of those things is the environment variables to set. And, by coincidence, the environment variables are <em>mostly</em> just fields from the derivation â€“ but reformatted to strings, or paths, or whatever, in accordance with the rules we already learned.</p>
<p>Okay. I feel good about that answer.</p>
<p>So: a <code>.drv</code> file contains just enough information that Nix needs to build a derivation, without needing to evaluate any Nix expressions. It also includes the derivationâ€™s dependencies (just build time? Runtime and build time?), the command it runs, the arguments to it passes to it, and the environment to run it with.</p>
<p><em>Anyway</em>.</p>
<p>So we have a <code>.drv</code> file.</p>
<p>Now, what does it mean to add a <code>.drv</code> file as a GC root?</p>
<p>Wellâ€¦ so theoretically, I would <em>expect</em> that adding a GC root means that a package and all of its <em>runtime</em> dependencies will not be garbage collected.</p>
<p>But of course, my <code>shell.nix</code> file doesnâ€™t <em>have</em> any runtime dependencies.</p>
<p>Which is the crux of the problem, I think.</p>
<p>In my head, I think of my shell as having runtime dependencies on the shell binary itself and on all of the things in my <code>PATH</code> within that shellâ€™s environment. I think of <code>shell.nix</code> as producing an expression for this whole runtime â€œenvironment.â€</p>
<p>But that isnâ€™t how it works.</p>
<p>I could <em>write</em> that expression, I think. I could make some derivation and â€œrealizeâ€ it into a development environment, a shell with runtime dependencies on all of these packages, and then I could just add that â€œresultâ€ (what would it look like? A special build of <code>zsh</code> with a builtin automatic <code>.zshenv</code> file?)</p>
<p>Anyway: this fantasy is only sort of relevant, because Iâ€™m not even adding a <em>package</em> as a GC root. Iâ€™m just adding a <code>.drv</code> file.</p>
<p>I donâ€™t know why I would ever have a <code>.drv</code> file as a GC root â€“ itâ€™s not like I can ever â€œinstallâ€ such a file. I think of <code>.drv</code> files as a weird implementation detail of Nix, and not something that I create directly.</p>
<p>But I just created one directly. I havenâ€™t added it as a GC root yet! But I will in a minute. And when I do, what would I <em>like</em> to happen?</p>
<p>Well, I would like it if adding a <code>.drv</code> file as a root meant that all <em>build-time</em> dependencies of my (unrealizable) <code>xxx-nix-shell</code> derivation would become un-garbage-collectable. I would like it if adding a package as a root meant adding its runtime dependencies, and if adding a <code>.drv</code> file meant adding all of its build dependencies.</p>
<p>This <em>seems</em> like a nice interpretation, a nice overloading, since I donâ€™t <em>think</em> you would ever have a <code>.drv</code> file as a GC root otherwise.</p>
<p>Butâ€¦ this does not seem to be the way that the world works. Adding a <code>.drv</code> file as a GC root appears to be the same as adding the output of that <code>.drv</code> file.</p>
<p>But letâ€™s verify that experimentally. Lets consider the package <code>souffle</code>, because thatâ€™s something from my <code>shell.nix</code> file that is currently not going to survive:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead | grep souffle
finding garbage collector roots...
determining live/dead paths...
/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2
/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv
</code></pre><p>Yep. And now letâ€™s add my <code>.drv</code> file as a GC rootâ€¦</p>
<pre tabindex=0><code>$ ln -s /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv \
&gt;       /nix/var/nix/gcroots/per-user/ian/nix-shell-test
</code></pre><p>And repeat:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead | grep souffle
finding garbage collector roots...
determining live/dead paths...
/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2
</code></pre><p>Interesting! The <code>.drv</code> file is no longer â€œdead.â€ So adding this to my roots did do <em>something</em> to the build-time dependencies. Butâ€¦ why do I care about the <code>.drv</code> file? Why would I want to keep it around?</p>
<p>It is at this point that we must remember the first two pieces of Nix config that we ever learned: <code>keep-derivations</code> and <code>keep-outputs</code>. From <code>man nix.conf</code>:</p>
<blockquote>
<pre tabindex=0><code>keep-derivations
</code></pre><p>If <code>true</code> (default), the garbage collector will keep the derivations from which non-garbage store paths were built. If <code>false</code>, they will be deleted unless explicitly registered as a root (or reachable from other roots).</p>
<p>Keeping derivation around is useful for querying and traceability (e.g., it allows you to ask with what dependencies or options a store path was built), so by default this option is on. Turn it off to save a bit of disk space (or a lot if <code>keep-outputs</code> is also turned on).</p>
<pre tabindex=0><code>keep-outputs
</code></pre><p>If <code>true</code>, the garbage collector will keep the outputs of non-garbage derivations. If <code>false</code> (default), outputs will be deleted unless they are GC roots themselves (or reachable from other roots).</p>
<p>In general, outputs must be registered as roots separately. However, even if the output of a derivation is registered as a root, the collector will still delete store paths that are used only at build time (e.g., the C compiler, or source tarballs downloaded from the network). To prevent it from doing so, set this option to <code>true</code>.</p>
</blockquote>
<p>Now, I hope that itâ€™s not too controversial for me to say: these are <em>terrible</em> names for these config values. The names tell me nothing: the terms <code>derivations</code> and <code>outputs</code> can mean <em>quite a lot of things</em>.</p>
<p>It <em>appears</em> that what <code>keep-derivations</code> means is â€œkeep <code>.drv</code> files.â€</p>
<p>Which <code>.drv</code> files? From reading the text, I would think expect it to mean â€œfor every live store path, also keep the <code>.drv</code> file that created that store path.â€</p>
<p>But it appears to be more than that. For example, when we added our <code>.drv</code> file as a GC root, suddenly the <code>souffle.drv</code> file became live. I <em>assume</em> thatâ€™s as a result of my having <code>keep-derivations = true</code>. But letâ€™s check. I turned that off:</p>
<pre tabindex=0><code>$ grep keep-derivations ~/.config/nix/nix.conf
keep-derivations = false

$ nix-store --gc --print-dead | grep souffle
finding garbage collector roots...
determining live/dead paths...
/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2
</code></pre><p>Nope! Didnâ€™t matter. Okay. So my guess was wrong, and I suppose that <code>keep-derivations</code> does actually mean just the thing I said it meant. Which is good: I should have trusted the man pages.</p>
<p>But thenâ€¦ why is the <code>souffle.drv</code> file no longer dead?</p>
<p>I mean, apparently because itâ€™s â€œa dependencyâ€ of my <code>nix-shell.drv</code>. I can see that thatâ€™s the case:</p>
<pre tabindex=0><code>$ nix-store --query --references /nix/store/4n40rm31n58ga0xl62nanq13a34axwwx-nix-shell.drv
/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh
/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv
/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv
/nix/store/gngpiflribp4h76hz4yrfm68vhs50d23-python3.9-cram-0.7.drv
/nix/store/sqs3pqphn9jbizwxmp8zvfcfg1lp2prm-souffle-2.0.2.drv
</code></pre><p>But itâ€™s only a â€œbuild timeâ€ dependency.</p>
<p>Hmm.</p>
<p>I think I might be thinking about â€œbuild timeâ€ and â€œruntimeâ€ dependencies wrong.</p>
<p>My mind has come up with a new mental model: that Nix makes no such distinction.</p>
<p>That there is only one kind of reference. Store objects can reference other store objects by including their path.</p>
<p>This <code>.drv</code> file references a bunch of other <code>.drv</code> files.</p>
<p>Nix doesnâ€™t know that theyâ€™re build-time dependencies. Nix doesnâ€™t care. It just sees that theyâ€™re referenced, so it keeps them alive.</p>
<p><em>If</em> I were to realize this derivation into some shell-like environment, then that <em>output</em> path would presumably reference the <em>outputs</em> of all of these <code>.drv</code> files, like <code>souffle</code> and <code>python3.9-cram</code> and whatever else.</p>
<p>But Nix doesnâ€™t know that itâ€™s a â€œbuild timeâ€ or a â€œruntimeâ€ dependency. Theyâ€™re all just dependencies: it just so happens that a <code>.drv</code> file will depend on other <code>.drv</code> files, while a regular path â€“ an â€œoutputâ€ â€“ probably doesnâ€™t depend on any <code>.drv</code> files. It probably just depends on other â€œoutputs.â€</p>
<p>And thatâ€™s all Nix really needs to know.</p>
<p>Yeah. That is a simple, elegant notion.</p>
<p>So <code>keep-outputs</code> and <code>keep-derivations</code> are mirrors of one another. One says â€œIf an output is alive, keep its <code>.drv</code> alive.â€ And the other says â€œIf a <code>.drv</code> is alive, keep its output alive.â€</p>
<p>I said <code>keep-outputs</code> and <code>keep-derivations</code> were â€“ and I used the italics â€“ <em>terrible</em> names, but I feel like I need to walk that back a little. They are <em>okay</em> names <em>if</em> you already know what they mean. But they are notâ€¦ good names. They are still bad names, I think.</p>
<p>What would I name them?</p>
<p>Perhaps something to reflect their symmetry. <code>paths-sustain-derivers</code> and <code>derivers-sustain-paths</code>?</p>
<p>No; I donâ€™t like â€œsustain.â€ Whatâ€™s a better word for â€œkeep alive?â€ Nurture? Nourish? No. Worse. Just say the whole thing: <code>outputs-keep-derivers-alive</code> and <code>derivers-keep-outputs-alive</code>.</p>
<p>Iâ€™m probably using â€œderiverâ€ wrong. I remember that as a term from the Nix database schema, but itâ€™s never been defined.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p>
<p>Anyway.</p>
<p>I understand what these options do, now. But thereâ€™s a little bit of roundabout reasoning required to get to the â€œwhat you use them forâ€ bit. <code>keep-outputs</code> was introduced in the manual, along with <code>keep-derivations</code>, as:</p>
<blockquote>
<p>The defaults will ensure that all derivations that are build-time dependencies of garbage collector roots will be kept and that all output paths that are runtime dependencies will be kept as well. All other derivations or paths will be collected. (This is usually what you want, but while you are developing it may make sense to keep outputs to ensure that rebuild times are quick.)</p>
</blockquote>
<p>Soâ€¦ I take some exception to this. Saying that â€œall output paths that are runtime dependencies will be kept as wellâ€ implies that that has something to do with these two options. But it <em>doesnâ€™t</em>, right? Thereâ€™s no option you can turn on that says â€œstop keeping references from valid paths alive.â€ All these options do is add one (each) additional reference to the set of references that every path has. Assuming that I actually have a handle on them.</p>
<p>But I feel pretty good about this explanation.</p>
<p>Anyway, the <em>reason</em> that <code>keep-outputs = true</code> is â€œnice for developersâ€ is that <em>when you also have <code>keep-derivations = true</code></em>, you get this chain of â€œrequisitesâ€ from your package to its build-time dependency:</p>
<pre><code>    (keep-derivations)    (reference)          (keep-outputs)
            |                  |                      |
my-package --&gt; my-package.drv --&gt; build-time-dep.drv --&gt; build-time-dep
</code></pre>
<p>(Arrows mean â€œkeeps alive;â€ parentheticals explain why those arrows are there.)</p>
<p>Okay. Thatâ€™s the missing piece.</p>
<p>Is this <em>right?</em> Is any of this <em>right?</em></p>
<p>Itâ€™s hard to <em>observe</em>. <code>nix-store --query --references</code> doesnâ€™t seem to care whether what I have <code>keep-derivations</code> set to: it never shows the <code>.drv</code> as a â€œreference.â€ These options only seem to affect the behavior of the garbage collector, so I have to do some dumb stuff to see it. There doesnâ€™t seem to be any way to ask Nix for â€œpaths this path is keeping alive.â€</p>
<p>Letâ€™s look at a package that I recently built from source: <code>sexp</code>:</p>
<pre tabindex=0><code>$ readlink =sexp
/nix/store/plnqysh4yd9xr3903rd73q9062y1kjc4-ocaml4.12.0-sexp-0.14.0/bin/sexp

$ nix-store --query --deriver /nix/store/plnqysh4yd9xr3903rd73q9062y1kjc4-ocaml4.12.0-sexp-0.14.0
/nix/store/i9rln1v40aqmbm61dh7qbbrvm6dj64ap-ocaml4.12.0-sexp-0.14.0.drv

$ nix-store --gc --print-dead --option keep-derivations true | grep -- -sexp-0.14.0
finding garbage collector roots...
determining live/dead paths...

$ nix-store --gc --print-dead --option keep-derivations false | grep -- -sexp-0.14.0
finding garbage collector roots...
determining live/dead paths...
/nix/store/i9rln1v40aqmbm61dh7qbbrvm6dj64ap-ocaml4.12.0-sexp-0.14.0.drv
</code></pre><p>Excellent. Okay. So yes; <code>keep-derivations = true</code> is keeping the <code>.drv</code> file alive.</p>
<p>Now letâ€™s take a look at a build-time dependency of this package:</p>
<pre tabindex=0><code>$ nix-store --query --references /nix/store/i9rln1v40aqmbm61dh7qbbrvm6dj64ap-ocaml4.12.0-sexp-0.14.0.drv
/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh
/nix/store/s5mjnf3b6nmxpyy640mx0s78zspihn2y-bash-4.4-p23.drv
/nix/store/8mgqiwshdp8pvl7agmi1ls6m2ziwp4ag-stdenv-darwin.drv
/nix/store/9sksjn5ak1cgqy0csb7x0nbkkypifzwv-ocaml-4.12.0.drv
/nix/store/d9ixwf1rc6c1r78400pimc5ywahb40dl-ocaml-findlib-1.9.1.drv
/nix/store/610ys4r0nz8fihhrb7xp109wh1v3yrcv-dune-2.8.5.drv
/nix/store/187l03fyxfi0jm2f04m1qld3iwvl4asi-ocaml4.12.0-sexp_pretty-0.14.0.drv
/nix/store/35mcw18bfsrl6p4lzmbbx7ji36s10kqv-ocaml4.12.0-sexp_diff_kernel-0.14.0.drv
/nix/store/4iypn7j2vq72w94cvsbsk3zc8nq98fky-ocaml4.12.0-sexp_select-0.14.0.drv
/nix/store/gq0jrpkq8m8xa92ikp2s0g392kcm1ja8-ocaml4.12.0-re2-0.14.0.drv
/nix/store/py1x0nk3f20v6ygj2ks3jv5lgjd87y1w-ocaml4.12.0-core-0.14.1.drv
/nix/store/ic9wg5krlcbsyq3dldxai0ns1kchiqr3-ocaml4.12.0-csvfields-0.14.0.drv
/nix/store/va8rpd48cazh7lvs5x0zd7lasngprr1l-ocaml4.12.0-async-0.14.0.drv
/nix/store/kk9d867l7zpazmg1v5jxp2iqh3i87807-ocaml4.12.0-sexp_macro-0.14.0.drv
/nix/store/np89a0kwzfyb87dsir2gxf2l9yp0rxkh-sexp.patch
/nix/store/v3n68p8iikf9jzbf1lxl63sgsc5j283d-source.drv
</code></pre><p>Letâ€™s try <code>dune-2.8.5</code>, the OCaml build tool:<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p>
<pre tabindex=0><code>$ nix-store --query --outputs /nix/store/610ys4r0nz8fihhrb7xp109wh1v3yrcv-dune-2.8.5.drv
/nix/store/f88ff5qgviyd1gkzsw8jzsmgl5d020dw-dune-2.8.5
</code></pre><p>Does anything depend on <code>dune</code>?</p>
<pre tabindex=0><code>$ nix-store --query --referrers /nix/store/f88ff5qgviyd1gkzsw8jzsmgl5d020dw-dune-2.8.5
</code></pre><p>Nope! So it should be garbage-collected, with the default settings:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead --option keep-derivations true --option keep-outputs false | grep -- -dune-2.8.5
finding garbage collector roots...
determining live/dead paths...
/nix/store/f88ff5qgviyd1gkzsw8jzsmgl5d020dw-dune-2.8.5
</code></pre><p>Indeed! But note: its <code>.drv</code> file is <em>not</em> included in that list, because it is referenced by (at the very least) the original <code>sexp.drv</code>.</p>
<p>Now, I already saw that if I set <code>keep-derivations = false</code>, the <code>sexp.drv</code> file will no longer be alive. And that means that my <code>dune.drv</code> file will also no longer be alive:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead --option keep-derivations false --option keep-outputs false | grep -- -dune-2.8.5
finding garbage collector roots...
determining live/dead paths...
/nix/store/610ys4r0nz8fihhrb7xp109wh1v3yrcv-dune-2.8.5.drv
/nix/store/db0vzgnp3ra84kdg27q2ds3j4g5166wb-dune-2.8.5.tbz.drv
/nix/store/f88ff5qgviyd1gkzsw8jzsmgl5d020dw-dune-2.8.5
</code></pre><p>Apparently its source code, too. Neat, okay. All of that is expected.</p>
<p>Now it doesnâ€™t matter if I set <code>keep-outputs = true</code> at this point, because that would only keep <code>dune</code> alive if <code>dune.drv</code> were also alive â€“ which it isnâ€™t:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead --option keep-derivations false --option keep-outputs true | grep -- -dune-2.8.5
finding garbage collector roots...
determining live/dead paths...
/nix/store/610ys4r0nz8fihhrb7xp109wh1v3yrcv-dune-2.8.5.drv
/nix/store/db0vzgnp3ra84kdg27q2ds3j4g5166wb-dune-2.8.5.tbz.drv
/nix/store/f88ff5qgviyd1gkzsw8jzsmgl5d020dw-dune-2.8.5
</code></pre><p>Exactly the same output. But if we then say <code>keep-derivations = true</code>:</p>
<pre tabindex=0><code>$ nix-store --gc --print-dead --option keep-derivations true --option keep-outputs true | grep -- -dune-2.8.5
finding garbage collector roots...
determining live/dead paths...
</code></pre><p>Nothing is dead anymore, because of this chain:</p>
<pre tabindex=0><code>sexp -&gt; sexp.drv -&gt; dune.drv -&gt; dune
</code></pre><p>Okay. I get it! I understand these options.</p>
<p>And now: I understand how to keep my <code>shell.nix</code> environments around.</p>
<p>But this <code>keep-outputs</code> option is soâ€¦ <em>global</em>. What if I <em>just</em> want to keep my shell environments around, but I donâ€™t want to persist <em>all</em> build-time dependencies?</p>
<p>Then I think Iâ€™m in trouble. I doubt thereâ€™s a way to express that here. Maybe! Butâ€¦ Iâ€™m not optimistic.</p>
<p>But, when I think about it, I think I <em>always</em> want <code>keep-outputs = true</code>.</p>
<p>This is sort of a cop-out answer, because it means that I donâ€™t need to investigate any further. If I <em>were</em> to try to chase this down, I expect I would either wind up disappointed that there is no such mechanism, or I would write some weird shell-environment-derivation thing that doesnâ€™t really fit into the â€œnormalâ€ <code>nix-shell</code>-based Nix ecosystem.</p>
<p>But I donâ€™t want to. Iâ€™m happy to keep my build-time dependencies around. After all, I installed <code>sexp</code> just now, and <em>one day</em> Iâ€™ll probably want to upgrade it to a newer version. Do I want to reinstall <code>ocaml</code> and <code>dune</code> and everything when that time comes? I do not. So why not be ready?</p>
<h1 id=okay-back-to-the-thing-from-the-wiki>okay back to the thing from the wiki</h1>
<p>Okay. So that was the missing piece: the reason the instructions in the wiki didnâ€™t work for me. Because I didnâ€™t have <code>keep-outputs = true</code>. Now, as previously stated, I already knew that, because I happened to read something that said that and it saved me really quite a lot of time.</p>
<blockquote>
<p>When you invoke <code>nix-shell</code> with</p>
<pre tabindex=0><code>$ nix-instantiate shell.nix --indirect --add-root $DIR/.nix-gc-roots/shell.drv ...
</code></pre><p>then youâ€™ll have a persistent environment which wonâ€™t be garbage collected. It is useful when you donâ€™t want to spend time waiting for redownloads every time you enter the shell.</p>
<p>A little problem exists though. GC roots are numbered sequentially, so if you change <code>shell.nix</code> to contain <strong>less</strong> derivations, and name of last GC root will start with <code>shell.drv-7</code>, then <code>shell.drv-{8,9,10,11,12}*</code> will be dangling and unused. To overcome this problem you should remove GC roots dir periodically (or just before <code>nix-shell</code>)</p>
</blockquote>
<p>Letâ€™s look at the rest of that. I can guess what <code>--add-root</code> is, althoughâ€¦ why does it take a path? I would think I would just need to pass a name for the symlink. I guess that makes it easier to delete the root later? Thatâ€™s a decent answer. Donâ€™t know about <code>--indirect</code>, though.</p>
<p><code>man nix-instantiate</code> says:</p>
<blockquote>
<pre tabindex=0><code>--add-root path, --indirect
</code></pre><p>See the corresponding options in <code>nix-store</code>.</p>
</blockquote>
<p>Okay. <code>man nix-store</code> says:</p>
<blockquote>
<pre tabindex=0><code>--add-root path
</code></pre><p>Causes the result of a realisation (<code>--realise</code> and <code>--force-realise</code>) to be registered as a root of the garbage collector. The root is stored in <code>path</code>, which must be inside a directory that is scanned for roots by the garbage collector (i.e., typically in a subdirectory of <code>/nix/var/nix/gcroots/</code>) unless the <code>--indirect</code> flag is used.</p>
<p>If there are multiple results, then multiple symlinks will be created by sequentially numbering symlinks beyond the first one (e.g., <code>foo</code>, <code>foo-2</code>, <code>foo-3</code>, and so on).</p>
<pre tabindex=0><code>--indirect
</code></pre><p>In conjunction with <code>--add-root</code>, this option allows roots to be stored outside of the GC roots directory. This is useful for commands such as nix-build that place a symlink to the build result in the current directory; such a build result should not be garbage-collected unless the symlink is removed.</p>
<p>The <code>--indirect</code> flag causes a uniquely named symlink to path to be stored in <code>/nix/var/nix/gcroots/auto/</code>.</p>
</blockquote>
<p>Okay. I feel good about that. That answers all my questions. It also explains the dangling <code>.drv</code> thing:</p>
<blockquote>
<p>A little problem exists though. GC roots are numbered sequentially, so if you change <code>shell.nix</code> to contain <strong>less</strong> derivations, and name of last GC root will start with <code>shell.drv-7</code>, then <code>shell.drv-{8,9,10,11,12}*</code> will be dangling and unused. To overcome this problem you should remove GC roots dir periodically (or just before <code>nix-shell</code>)</p>
</blockquote>
<p>Okay. I thought this meant if I removed dependencies, but it actually literally means if I have a <code>shell.nix</code> file that evaluates to multiple derivations. Thatâ€™s a very subtle gotcha! Iâ€™m glad that the wiki calls it out.</p>
<p>Okay! I understand all of this now. I know how to save my shell dependencies. It was surprisingly difficult, you know, to get here. This was a long journey that we went on together. But we made it, and weâ€™re stronger for having gone through this.</p>
<h1 id=wait-so-im-just-supposed-to-run-this-weird-command-all-the-time>wait so iâ€™m just supposed to run this weird command all the time</h1>
<p>Yeah. So one big problem with adding the <code>.drv</code> file as a root, instead of the <code>shell.nix</code> file, is that you need to <em>manually</em> preserve its dependencies. If you add a dependency to your <code>shell.nix</code> file, itâ€™s suddenly in danger of garbage collection. If you remove a dependency, itâ€™s not going to get garbage collected.</p>
<p>You need to manually run this <code>nix-instantiate</code> command any time your <code>shell.nix</code> file changes.</p>
<p>Which is annoying.</p>
<p>But not <em>that</em> annoying. Basically, instead of <code>nix-shell</code>, I have to run:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>rm -rf ./.nix-gc-roots
nix-instantiate shell.nix --indirect --add-root ./.nix-gc-roots/shell.drv
nix-shell
</code></pre></div><p>I add something close to this to <a href=https://ianthehenry.com/posts/sd-my-script-directory/>my script directory</a> as <a href=https://github.com/ianthehenry/sd-nix><code>sd nix shell</code></a>, for now. It adds a couple seconds to shell startup time, but it already takes a couple seconds to start the shell, and thatâ€™s kind of a one-time cost, so it feels acceptable.</p>
<p>A <em>nicer</em> solution might be to make my own custom <code>sd nix gc</code>, which <em>allows</em> me to include <code>shell.nix</code> files as â€œroots,â€ and will â€œinstantiateâ€ them into derivations just-in-time. Thatâ€™s a bit nicer of an API, assuming I actually remembered to use that command. But itâ€™s a bit worse, in a lot of other ways: it would make the output of <code>--print-dead</code> misleading, for example.</p>
<p>But I could set it up so that, not only would it instantiate the <code>.drv</code> file, but it could also create an object that referenced all of its outputs, so that I wouldnâ€™t need <code>keep-outputs = true</code> globally for it to work.</p>
<pre tabindex=0><code>$ nix-store --query --outputs $(nix-store --query --references $(nix-instantiate shell.nix) | grep '\.drv$')
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/6adx3kbv08fmm1szijhvwagm4qi4ww0z-bash-4.4-p23-dev
/nix/store/vslnny73cjifv6wcc4q8irk585ng2jhi-bash-4.4-p23-doc
/nix/store/bs8scmsr270jbpmzg65kcgxgqqfzgwyd-bash-4.4-p23-info
/nix/store/ifazwf1sd54mbqz9a68r932kc371n9rn-bash-4.4-p23-man
/nix/store/30njb8l701pwnm5ya749fh2cgyc2d70m-bash-4.4-p23
/nix/store/59hdixd6qf2jq5mj0bqiwrhy7621wa7j-stdenv-darwin
/nix/store/axzlbh5ji9pr97mi04f70lizn22bkxj5-python3.9-cram-0.7
/nix/store/n0wm6l7qk9ygzjd76ashf9xx7f0z3kh6-souffle-2.0.2
</code></pre><p>Yeah, and then I could maybeâ€¦</p>
<pre tabindex=0><code>$ nix-store --add &lt;(nix-store --query --outputs $(nix-store --query --references $(nix-instantiate shell.nix) | grep '\.drv$'))
error: file '/dev/fd/11' has an unsupported type
</code></pre><p>Aww. <code>/dev/stdin</code> also fails, but silently.</p>
<p>Well, I can write it to a temporary file, and then <code>nix-store --add</code> thatâ€¦</p>
<pre tabindex=0><code>$ nix-store --add shell-deps
/nix/store/d0kni63ckxrym04j70favdz399x1g26y-shell-deps

$ nix-store --query --references /nix/store/d0kni63ckxrym04j70favdz399x1g26y-shell-deps
</code></pre><p>Hey! Why doesnâ€™t that work?</p>
<p>I guess I donâ€™t really know how the <code>--references</code> calculation works. Obviously it doesnâ€™t just <code>grep</code> for things that look like Nix paths when it adds them to the store â€“ which makes sense, now that I think about it, since you wouldnâ€™t want it to like include spurious references to things just because your <code>README</code> or something included a Nix path.</p>
<p>Itâ€™s probably determining references when it realizes a derivation? As like the intersection of paths-that-occur-in-output and derivations-referenced-by-deriver?</p>
<p>I donâ€™t know.</p>
<p>Anyway; Iâ€™m just gonna stick with the dumb <code>sd nix shell</code> thing for now.</p>
<h1 id=one-last-thing>one last thing</h1>
<p>Before I go, I want to say something about <code>keep-env-derivations</code>. <code>man nix.conf</code> describes it thusly:</p>
<blockquote>
<pre tabindex=0><code>keep-env-derivations
</code></pre><p>If <code>false</code> (default), derivations are not stored in Nix user environments. That is, the derivations of any build-time-only dependencies may be garbage-collected.</p>
<p>If <code>true</code>, when you add a Nix derivation to a user environment, the path of the derivation is stored in the user environment. Thus, the derivation will not be garbage-collected until the user environment generation is deleted (<code>nix-env --delete-generations</code>). To prevent build-time-only dependencies from being collected, you should also turn on <code>keep-outputs</code>.</p>
<p>The difference between this option and <code>keep-derivations</code> is that this one is â€œstickyâ€: it applies to any user environment created while this option was enabled, while <code>keep-derivations</code> only applies at the moment the garbage collector is run.</p>
</blockquote>
<p>When I first encountered this option, it sounded like some kind of weird magic.</p>
<p>Now I donâ€™t think so: now I think that all this does is create references, in the user environment, to all the <code>.drv</code> files of the outputs in your environment.</p>
<pre tabindex=0><code>$ nix-env --profile ~/scratch/profile -iA nixpkgs.hello
installing 'hello-2.10'
building '/nix/store/0w004p7ffk9vqppzk07brchvzz9mcy27-user-environment.drv'...
created 2 symlinks in user environment

$ tree -l ~/scratch/profile
/Users/ian/scratch/profile
â”œâ”€â”€ bin -&gt; /nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10/bin
â”‚   â””â”€â”€ hello
â”œâ”€â”€ manifest.nix -&gt; /nix/store/0bx5f3ny86lyvsfaj11xq3w00m98cy5b-env-manifest.nix
â””â”€â”€ share -&gt; /nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10/share
    â”œâ”€â”€ info
    â”‚   â””â”€â”€ hello.info
    â””â”€â”€ man
        â””â”€â”€ man1
            â””â”€â”€ hello.1.gz
</code></pre><p>And with the option set:</p>
<pre tabindex=0><code>$ nix-env --option keep-env-derivations true --profile ~/scratch/profile -iA nixpkgs.hello

$ tree -l ~/scratch/profile
/Users/ian/scratch/profile
â”œâ”€â”€ bin -&gt; /nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10/bin
â”‚   â””â”€â”€ hello
â”œâ”€â”€ manifest.nix -&gt; /nix/store/49mhisak7595v2bijqgg3mv4rdq95h4n-env-manifest.nix
â””â”€â”€ share -&gt; /nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10/share
    â”œâ”€â”€ info
    â”‚   â””â”€â”€ hello.info
    â””â”€â”€ man
        â””â”€â”€ man1
            â””â”€â”€ hello.1.gz
</code></pre><p>All the same files. But nowâ€¦</p>
<pre tabindex=0><code>$ nix-store --query --references ~/scratch/profile-1-link
/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10
/nix/store/0bx5f3ny86lyvsfaj11xq3w00m98cy5b-env-manifest.nix

$ nix-store --query --references ~/scratch/profile-2-link
/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10
/nix/store/49mhisak7595v2bijqgg3mv4rdq95h4n-env-manifest.nix
</code></pre><p>Hmm. I guess I was wrong.</p>
<p>I was expecting that the <code>manifest.nix</code> would be different, and it would include the derivation path.</p>
<p>Oh! But it does. You just need to look in <code>requisites</code> (mnemonic: reqursive references) instead:</p>
<pre tabindex=0><code>$ nix-store --query --requisites ~/scratch/profile-1-link | grep hello-2.10.drv

$ nix-store --query --requisites ~/scratch/profile-2-link | grep hello-2.10.drv
/nix/store/2cb13m5fr4c9fdrnhs1jpws4r26dspav-hello-2.10.drv
</code></pre><p>And indeed, it does just appear as text in the <code>manifest.nix</code> file:</p>
<pre tabindex=0><code>$ nix-store --query --references ~/scratch/profile-1-link/manifest.nix
/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10

$ nix-store --query --references ~/scratch/profile-2-link/manifest.nix
/nix/store/2cb13m5fr4c9fdrnhs1jpws4r26dspav-hello-2.10.drv
/nix/store/pl4yqgxabnwf56lm0yf9hzy1gmsmwrkr-hello-2.10
</code></pre><p>But itâ€™s one giant un-pretty-printed Nix expression, so I donâ€™t want to show it to you. You get it. I think weâ€™re done here.</p>
<aside>
<p>This solution is actually <em>slightly</em> incomplete.</p>
<p>It will not prevent the derivation <code>nixpkgs.bashInteractive</code> from being garbage collected, which contains the actual <code>bash</code> binary that <code>nix-shell</code> invokes. You can fix this by setting an explicit <code>NIX_BUILD_SHELL</code> to your installed <code>bash</code>, or by manually registering <code>nixpkgs.bashInteractive</code> as a root. See <a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Part 42: Running zsh in nix-shell</a> for more information.</p>
</aside>
<h1 id=theres-a-better-way><em>thereâ€™s a better way</em></h1>
<p>Some time after I published this blog post, <a href=https://vaibhavsagar.com/>Vaibhav Sagar</a> wrote to me about a <em>much better</em> way to do this.</p>
<p>It turns out that all derivations created with <code>mkDerivation</code> â€“ which includes any created with <code>mkShell</code> â€“ have a <em>secret attribute</em> called <code>inputDerivation</code>. Itâ€™s exactly what I wanted to construct above, but couldnâ€™t figure out how: a derivation whose <em>runtime dependencies</em> are equal to the <em>build-time dependencies</em> of my shell.</p>
<p>Itâ€™s a much simpler solution, and most importantly it doesnâ€™t require setting <code>keep-outputs = true</code>, so it just works out of the box.</p>
<p>Instead of:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>rm -rf ./.nix-gc-roots
nix-instantiate shell.nix --indirect --add-root ./.nix-gc-roots/shell.drv
nix-shell shell.nix
</code></pre></div><p>You can just run:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nix-build shell.nix -A inputDerivation -o .nix-shell-inputs
nix-shell shell.nix
</code></pre></div><p>I donâ€™t think this would work if you have a <code>shell.nix</code> that evaluates to multiple derivations, for some reason. But since thatâ€™s something I donâ€™t care about at all, I am happy to turn off my global <code>keep-outputs</code> and revel in the simplicity of this solution.</p>
<p>You can read a lot more about this in <a href=https://github.com/NixOS/nixpkgs/pull/95536>the PR that introduced <code>inputDerivation</code></a>.</p>
<p>Also note that as of Nix 2.4, the experimental <code>nix develop</code> command has a built-in way to do this, which is great â€“ itâ€™s much more discoverable, at the very least. But experience tells me that <code>nix develop</code> is still <em>very</em> experimental, and I have not switched over to it yet.</p>
<h1 id=beware-infinite-store-bloat>Beware: infinite store bloat</h1>
<p>Something to be aware of if youâ€™re using an approach like this is that the gcroots for all of your shells are going to stick around <em>forever</em>.</p>
<p>Which, yes, is kind of the point. But since a default <code>mkShell</code>/<code>mkShellNoCC</code> is going to depend on quite a lot of things â€“ all of <code>stdenv</code>/<code>stdenvNoCC</code> at the very least â€“ you might not want to make sure you try to rebuild all of your shells after a <code>nix-channel --update</code>, so that you donâ€™t wind up with a copy of every historical <code>stdenv</code> filling up your <code>/nix/store</code>.</p>
<p>Or just delete old <code>.nix-shell-inputs</code> files for projects you arenâ€™t actively working on. Remember that you can find a list of them in <code>/nix/var/nix/gcroots/auto</code>.</p>
<hr>
<ul>
<li>How does Nix calculate the set of references for an output?</li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>I edited the wiki after writing this post, so you may see something different there today.&nbsp;<a href=#fnref:1 class=footnote-backref role=doc-backlink>â†©ï¸</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>Erratum: it is defined! I just forgot. The glossary says:</p>
<blockquote>
<p>The deriver of an output path is the store derivation that built it.</p>
</blockquote>
<p>So. I was using it correctly. Good.&nbsp;<a href=#fnref:2 class=footnote-backref role=doc-backlink>â†©ï¸</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p>I originally tried <code>ocaml-4.12.0</code>, the OCaml compiler, but it seems that OCaml packages have some runtime dependency on <em>something</em> in there, much to my surprise. These are statically linked binaries, so Iâ€™m guessing the dependency is something dumb like the <code>RPATH</code> issue that gets <code>patchelf</code>â€™d away on Linux. But I do not bother to actually look into it.&nbsp;<a href=#fnref:3 class=footnote-backref role=doc-backlink>â†©ï¸</a></p>
</li>
</ol>
</section></div>
</article>
<div class=post-footer>
<a href="mailto:ianthehenry@gmail.com?subject=let%27s%20talk%20about%20%22Saving%20your%20shell%22&amp;body=First%20of%20all,%20I%20just%20wanted%20to%20say%20that%20I%20forgive%20you%20for%20not%20having%20a%20real%20comment%20system%20on%20your%20site.">comment on this post</a><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Next up âœ Nix Pills</a></div>
<aside class=series-rider>
<p>
This post is part of the series <a class=series-name href=https://ianthehenry.com/posts/how-to-learn-nix/>How to Learn Nix</a>.
You can
<a target=_blank href=https://ianthehenry.com/feed.xml>subscribe to my RSS feed</a>
or
<a target=_blank href=https://twitter.com/ianthehenry>follow me on Twitter</a>
for more, or <a href=https://ianthehenry.com/posts/>peruse my back catalog</a> if you're in the mood for something different.
<div class=subsection-header>Opening remarks</div><ol start=1 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/introduction/>What's all this about?</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/prior-knowledge/>Prior knowledge</a></li>
</ol><div class=subsection-header>Reading the Nix manual</div><ol start=3 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/glossary/>What we talk about when we talk about Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/quick-start-guide/>Quick starts, full hearts</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/basic-package-management/>Basic package management</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/profiles/>Profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/garbage-collection/>Garbage collection</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/channels/>Channels</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/sharing/>Learning to share</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>My first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/okay-my-actual-first-derivation/>Okay my actual first derivation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-language/>The Nix expression language</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations/>Derivations</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/built-in-functions/>Built-in Functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/advanced-topics/>Advanced Topics</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/command-reference/>Command Reference</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/configuration/>Configuration</a></li>
</ol><div class=subsection-header>Interlude: in which we follow our hearts, however briefly</div><ol start=18 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-manual-reflection/>So I read the manual huh</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/>Switching from Homebrew to Nix</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-nix-bug/>My first Nix bug</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-package-upgrade/>My first package upgrade</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/>Setting up a declarative user environment</a></li>
</ol><div class=subsection-header>Reading the Nixpkgs manual</div><ol start=23 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/>How to learn Nixpkgs</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overlays/>Overlays</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/overriding/>Overriding</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/an-infinite-list-of-functions/>An infinite list of functions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/even-more-functions-somehow/>Even more functions, somehow</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/the-standard-environment/>The standard environment</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>Derivations in detail</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/cross-compilation/>Cross-compilation</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/platform-notes/>Platform notes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/builders/>Builders</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/languages-and-frameworks/>Languages and frameworks</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/random-package-grab-bag/>Random package grab-bag</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/how-to-give-back/>How to give back</a></li>
</ol><div class=subsection-header>Documentation behind us, we set out on our own</div><ol start=36 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nixpkgs-reflection/>So I read the other manual, huh</a></li>
<li><strong><a href=https://ianthehenry.com/posts/how-to-learn-nix/saving-your-shell/>Saving your shell</a></strong>&nbsp;â†&nbsp;you are here</li>
</ol><div class=subsection-header>Oh right forgot about Nix Pills</div><ol start=38 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-pills/>Nix Pills</a></li>
</ol><div class=subsection-header>Our whole lives ahead of us</div><ol start=39 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/python3-alpha/>How to install Python</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/open-questions/>Open questions</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/ambiguous-packages/>Ambiguous packages</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-zshell/>Running zsh in nix-shell</a></li>
</ol><div class=subsection-header>Nix 2.4 slithers to life</div><ol start=43 class=post-list><li><a href=https://ianthehenry.com/posts/how-to-learn-nix/flakes/>My first brush with flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/more-flakes/>More flakes, unfortunately</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/new-profiles/>Fancy new profiles</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/chipping-away-at-flakes/>Chipping away at flakes</a></li>
<li><a href=https://ianthehenry.com/posts/how-to-learn-nix/nix-develop/>New and unimproved shells</a></li>
</ol>
</aside>
</main>
<footer>
Â© 1899-1907 <a href=https://ianthehenry.com/about/>Ian Henry</a>
</footer>
